{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blixxi Labs",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Everything related to AI",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2024/02/07/rag-application-with-langchain",
            "title": "Create LLM apps using RAG",
            "summary": "RAG and Langcahin for creating the personalized bots",
            "content_text": "If you‚Äôre considering making a personalized bot for your documents or your website that responds to you, you‚Äôre in the right spot. I‚Äôm here to help you create a bot using Langchain and RAG strategies for this purpose.Understanding the Limitations of ChatGPT and LLMsChatGPTs and other Large Language Models (LLMs) are extensively trained on text corpora to comprehend language semantics and coherence. Despite their impressive capabilities, these models have limitations that require careful consideration for particular use cases. One significant challenge is the potential for hallucinations, where the model might generate inaccurate or contextually irrelevant information.Imagine requesting the model to enhance your company policies; in such scenarios, ChatGPTs and other Large Language Models might struggle to provide factual responses because they lack training on your company‚Äôs data. Instead, they may generate nonsensical or irrelevant responses, which can be unhelpful. So, how can we ensure that an LLM comprehends our specific data and generates responses accordingly? This is where techniques like Retrieval Augmentation Generation (RAG) come to the rescue.What is RAG?RAG or Retrieval Augmented Generation uses three main workflows to generate and give the better response      Information Retrieval: When a user asks a question, the AI system retrieves the relevant data from a well-maintained knowledge library or external sources like databases, articles, APIs, or document repositories. This is achieved by converting the query into a numerical format or vector that can be understood by machines.        LLM: The retrieved data is then presented to the LLM or Large Language Model, along with the user‚Äôs query. The LLM uses this new knowledge and its training data to generate the response.        Response: Finally, the LLM generates a response that is more accurate and relevant since it has been augmented with the retrieved information. I mean we gave LLM some additional information from our Knowledge library which allows LLMs to provide more contextually relevant and factual responses, solving the problem of models when they are just hallucinating or providing irrelevant answer.  Let‚Äôs take the example of company policies again. Suppose you have an HR bot that handles queries related to your Company policies. Now if someones asks anything specific to the policies, The bot can pull the most recent policy documents from the knowledge libray, pass the relevant context to a well crafted prompt which is then passed further to the LLM for generating the response.To make it more easy, Imagine a LLM as your knowledgeable friend who seems to know everything, from Geography to Computer Science from Politics to Philosophy. Now, picture yourself asking this friend a few questions:  ‚ÄúWho handles my laundry on weekends?‚Äù  ‚ÄúWho lives next door to me?‚Äù  ‚ÄúWhat brand of peanut butter do I prefer?‚ÄùChances are, your friend wouldn‚Äôt be able to answer these questions. Most of the time, no. But let‚Äôs say this distant friend becomes closer to you over time, he comes at your place regularly, know your parents very well, you both hangout pretty often, you go on outings, blah blah blah.. You got the point.I mean he is gaining access to personal and insider information about you.  Now, when you pose the same questions, he can somehow answer those question with more relevance now because because he is better suited with your personal insights.Similarly, a LLM, when provided with additional information or access to your data, it won‚Äôt guess or hallucinate. Instead, it can leverage that data to provide more relevant and accurate answers.To break it down, here are the exact steps to create any RAG application‚Ä¶  Extract the relevant information from your data sources.  Break the information into the small chunks.  Store the chunks as their embedddings into a vector database.  Create a prompt template which will be fed to the LLM with the query and the context.  Convert the query to it‚Äôs relevant embedding using same embedding model.  Fetch k number of relevant documents related to the query from the vector database.  Pass the relevant documents to the LLM and get the response.FAQs      We will be using Langchain for this task, Basically it‚Äôs like a wrapper which lets you talk and manage to your LLM operations better.        Along with it we will be using Hugging Face,  it  an open-source library for building, training, and deploying state-of-the-art machine learning models, especially about NLP. To use the HuggingFace we need the access token, Get your access token here        For our models, we‚Äôll need two key components: a LLM (Large Language Model) and an embedding model. While paid sources like OpenAI offer these, we‚Äôll be utilizing open-source models to ensure accessibility for everyone.        To keep things simple, our data ingestion process will involve using a URL and some PDFs. While you can incorporate additional data sources if needed, we‚Äôll concentrate solely on these two for now.  With Langchain for the interface, Hugging Face for fetching the models, along with open-source components, we‚Äôre all set to go! This way, we will save some bucks while still having everything we need. Let‚Äôs move to the next stepsEnvironment SetupOpen your favorite editor, create a python environment and install the relevant dependenciespython3 -m venv envsource env/bin/activatepip3 install dotenv langchain langchain_community Now create a .env file in the same directory to place your Hugging Face api credentials like thisHUGGINGFACEHUB_API_TOKEN = hf_KKNWfBqgwCUOHdHFrBwQ.....Ensure the name ‚ÄúHUGGINGFACEHUB_API_TOKEN‚Äù remains unchanged, as it is crucial for authentication purposes.Finally create a data folder in the project‚Äôs root directory, designated as the central repository for storing PDF documents. You can add some sample PDFs for testing purposes; for instance, I am using the Yolo V7 and Transformers paper for demonstration. It‚Äôs important to note that this designated folder will function as our primary source for data ingestion.It seems like everything is in order, and we‚Äôre all set!Step 1 : Extracting the relevant informationTo get your RAG application running, the first thing we need to do is to extract the relevant information from the various data sources. It can be a website page, a PDF file, a notion link, a google doc whatever it is, it needs to be extracted from it‚Äôs original source first.from langchain.document_loaders import PyPDFLoaderfrom langchain_community.document_loaders import WebBaseLoader# Loading the environment variablesload_dotenv()HF_TOKEN = os.getenv(\"HUGGINGFACEHUB_API_TOKEN\")# Loading the web url and data url_loader = WebBaseLoader(\"https://docs.smith.langchain.com/overview\")documents_loader = DirectoryLoader('../data/', glob=\"./*.pdf\", loader_cls=PyPDFLoader)# Creating the instancesurl_docs = url_loader.load()data_docs = documents_loader.load()# Combining all the data that we ingesteddocs = url_docs + data_docsThis will ingest all the data from the URL link and the PDFs.Step 2 : Breaking the information into smaller chunksWe‚Äôve all the necessary data for developing our RAG application. Now, it‚Äôs time to break down this information into smaller chunks. Later, we‚Äôll utilize an embedding model to convert these chunks into their respective embeddings. But why it‚Äôs important?Think of it like this: If you‚Äôre tasked with digesting a 100-page book all at once and then asked a specific question about it, it would be challenging to retrieve the necessary information from the entire book to provide an answer. However, if you‚Äôre permitted to break the book into smaller, manageable chunks‚Äîlet‚Äôs say 10 pages each‚Äîand each chunk is labeled with an index from 0 to 9, the process becomes much simpler. When the same question is posed after this breakdown, you can easily locate the relevant chunk based on its index and then extract the information needed to answer the question accurately.Picture the book as your extracted information, with each 10-page segment representing a small chunk of data, and the index as the embedding. Essentially, we‚Äôll apply an embedding model to these chunks to transform the information into their respective embeddings. While as humans, we may not directly comprehend or relate to these embeddings, they serve as numeric representations of the chunks to our application.  This is how you can do this in Pythonfrom langchain.text_splitter import RecursiveCharacterTextSplittertext_splitter = RecursiveCharacterTextSplitter(chunk_size = 1000, chunk_overlap = 50)documents = text_splitter.split_documents(docs)Now the chunk_size parameter specifies the maximum number of characters that a chunk can contain, while the chunk_overlap parameter specifies the number of characters that should overlap between two adjacent chunks. With the chunk_overlap set to 50, the last 50 characters of the adjacent chunks will be shared between each other.This approach helps to prevent important information from being split across two chunks, ensuring that each chunk contains sufficient contextual information for the subsequent processing or analysis. As the shared information at the boundary of neighboring chunks enables a more seamless transition and understanding of the text‚Äôs content. The best strategy for choosing the chunk_size and chunk_overlap parameters largely depends on the nature of the documents and the purpose of the application.Step 3 : Creating the embeddings and store them into a vectordatabaseWe have two ways to generate the embeddings for these chunks. First, we can download a model, handle preprocessing and do computations on our own. Or, we can use Hugging Face‚Äôs model hub. They‚Äôve got lots of pre-trained models for different NLP tasks, including embedding generation.With this approach, we‚Äôll use one of their embedding models where we‚Äôll just give our chunks to this model, and Hugging Face‚Äôs servers will do the hard work like preprocessing and computing. This saves us from burning our own machines for those heavy computations. üíÄWe have a bunch of options for embedding models, and you can check out the leaderboard here and choose best one for your compatibility. But for now, we‚Äôll go with ‚Äúbge-base-en-v1.5‚Äù. It‚Äôs great for generating embeddings for English text, plus it‚Äôs smaller, so it loads quickly and gets the job done fast.from langchain.embeddings import HuggingFaceInferenceAPIEmbeddings# Creating the embeddings objectembeddings = HuggingFaceInferenceAPIEmbeddings(    api_key=HF_TOKEN, model_name=\"BAAI/bge-base-en-v1.5\")Here‚Äôs a way to see the number of embeddings for each chunkquery = \"Hello I want to see the length of the embeddings for this document.\"embeddings.embed_documents([query])[0]# 768We have the embeddings for our chunks, now we need a vector database to store them. When it comes to vector databases, there are plenty of options out there.DB like Pinecone are paid but offer fast performance and extra features compared to open-source alternatives like FAISS or Chroma. However, if you don‚Äôt need to scale your database to handle hundreds of users fetching and storing data every minute, open-source options are more than enough. Instead, they work really well. So, what we‚Äôll do we‚Äôll create  an instance of FAISS vector database and store our embeddings in it. It‚Äôs straightforward and doesn‚Äôt require any rocket science.from langchain_community.vectorstores import FAISS# Creating a vectorstore objectvectorstore = FAISS.from_documents(documents, embeddings)Step 4 : Create a prompt template which will be fed to the LLMOk now comes the prompt template. So when you write a question to the ChatGPT and it answers that question, you are basically providing a prompt to the model so that it can understand what‚Äôs the question is. When companies train the models, they decide what kind of prompt they are going to use for invoking the model and ask the question. For example, if you are working with ‚ÄúMistral 7B instruct‚Äù and you want the optimal results it‚Äôs recommended to use the following chat template:&lt;s&gt;[INST] Instruction [/INST] Model answer&lt;/s&gt;[INST] Follow-up instruction [/INST]Note that &lt;s&gt; and &lt;/s&gt; are special tokens to represent beginning of string (BOS) and end of string (EOS) while [INST] and [/INST] are regular strings. It‚Äôs just that the Mistral 7B instruct is made in such a way that the model look for those special tokens to understand the question better. Different types of LLMs have different kinds of instructed prompts.Now for our case we are going to use huggingfaceh4/zephyr-7b-alpha which is a text generation model. Just to make it clear, Zephyr-7B-Œ± has not been aligned or formated to human preferences with techniques like RLHF (Reinforcement Learning with Human Feedback) or deployed with in-the-loop filtering of responses like ChatGPT, so the model can produce problematic outputs (especially when prompted to do so).Instead of writing a Prompt of our own, I will use ChatPromptTemplate class which creates a prompt template for the chat models. In layman terms, instead of writing a specified prompt I am letting ChatPromptTemplate to do it for me. Here is an example prompt template that is being generated from the manual messsages.from langchain_core.prompts import ChatPromptTemplatechat_template = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful AI bot. Your name is {name}.\"),        (\"human\", \"Hello, how are you doing?\"),        (\"ai\", \"I'm doing well, thanks!\"),        (\"human\", \"{user_input}\"),    ])messages = chat_template.format_messages(name=\"Bob\", user_input=\"What is your name?\")If you don‚Äôt want to write the manual instructions, you can just use the from_template function to generate a more generic prompt template which I used for this project. Here it is..from langchain_core.prompts import ChatPromptTemplatetemplate = \"\"\"{query}\"\"\"prompt = ChatPromptTemplate.from_template(template)Our prompt is set! We‚Äôve crafted a single message, assuming it‚Äôs from a human xD . If you‚Äôre not using the from_messages function, the ChatPromptTemplate will ensure your prompt works seamlessly with the language model by reserving some additional system messages. While there‚Äôs always room for improvement with more generic prompts to achieve better results, this setup should work for now!Step 5 : Convert the query to it‚Äôs relevant embedding using same embedding model.Now, let‚Äôs talk about the query or question we want to ask our RAG application. We can‚Äôt just pass the query to our model and expect information in return. Instead, we need to pass the query through the same embedding model used for the chunks earlier. Why is this important? Well, by embedding queries, we allow models to compare them efficiently with previously processed chunks of text. This enables tasks like finding similar documents or generating relevant responses.It‚Äôs like translating language into a language computers understand. Imagine you‚Äôre an English speaker and your friend speaks Hindi. Neither of you understands each other‚Äôs language. You hand your English-speaking friend a one-page document written in Hindi. Your friend has to translate that document into English before they can understand it‚Äôs content. Now, if you ask a question in Hindi related to that document, your friend has to translate the question into English first to understand it, and then find a relevant response from the information you shared earlier. In this scenario, your friend acts like an embedding model. He converted your previous texts into the relevant language or embeddings if I say.Now, when you ask a query or question, it will be translated into the relevant embeddings using the same embedding model used for the chunks. Then, a search operation will be performed to find the relevant response to your query. I hope this clarifies why we converted our query into embeddings first.Step 6 : Fetch K number of documents.Now, let‚Äôs talk about the retriever. Its job is to dive into the vector database and perform a search to find relevant documents. It returns a set number, let‚Äôs call it ‚Äúk‚Äù, of these documents, which are ranked based on their contextual relevance to the query or question you asked. You can set ‚Äúk‚Äù as a parameter, indicating how many relevant documents you want - whether it‚Äôs 2, 5, or 10. Generally, if you have a smaller amount of data, it‚Äôs best to stick with a lower ‚Äúk‚Äù, around 2. For longer documents or larger datasets, a ‚Äúk‚Äù between 10 and 20 is recommended.Different search techniques can be employed to fetch relevant documents more effectively and quickly from a vector database. The choice depends on various factors such as your specific use case, the amount of data you have, what kind of vector database you are using and the context of your problem.retriever = vectorstore.as_retriever(search_type = \"mmr\", search_kwargs={\"k\": 3})docs = retriever.get_relevant_documents(\"what did you know about Yolo V7?\")print(docs)When you run this code, the retriever will fetch 3 most most relevant documents from the vector database based on the mmr search criteria. All these documents will be the contexts for our LLM model to generate the response for our query.Step 7 : Pass the relevant documents to the LLM and get the response.So far, we‚Äôve asked our retriever to fetch a set number of relevant documents from the database. Now, we need a language model (LLM) to generate a relevant response based on that context. To ensure robustness, let‚Äôs remember that at the beginning of this blog, I mentioned that LLMs like ChatGPT can sometimes generate irrelevant responses, especially when asked about specific use cases or contexts. However, this time, we‚Äôre providing the context from our own data to the LLM as a reference. So, it will consider this reference along with its general capabilities to answer the question. That‚Äôs the whole idea behind using RAG!Now, let‚Äôs dive into implementing the language model (LLM) aspect of our RAG setup. We‚Äôll be using zephyr model architecture from the Hugging Face Hub. Here‚Äôs how we do it in Python:from langchain.llms import HuggingFaceHub# Model architecturemodel =  HuggingFaceHub(    repo_id=\"huggingfaceh4/zephyr-7b-alpha\",    model_kwargs={\"temperature\": 0.5, \"max_length\": 4096 ,\"max_new_tokens\": 2048 })In this code snippet, we‚Äôre instantiating our language model using the Hugging Face Hub. Specifically, we‚Äôre selecting the zephyr 7 billion model which is placed in this repository ID ‚Äúhuggingfaceh4/zephyr-7b-alpha‚Äù. Choice of choosing this model isn‚Äôt arbitrary; as I said before, it‚Äôs based on the model‚Äôs suitability for our specific task and requirements. As we are already implementing only Open Source components, Zephyr 7 billion works good enough to generate the useful response with minimal overhead and low latency.This model comes with some additional parameters to fine-tune its behavior. We‚Äôve set the temperature to 0.5, which controls the randomness of the generated text. As a lower temperature tends to result in more conservative and predictable outputs and    when the temperature is set to max which is 1, the model tries to be as much creative as it could, so based on what type of output you want for your use case, you can tweak this parameter. For the sake of the simplicity and demonstration purposes, I set it to 0.5 to make sure we get decent results. Next is max_length parameter which defines the maximum length of the generated text and it includes the size of your prompt as well as the response.max_new_tokens sets the threshold on maximum number of new tokens that can be generated. As a general rule of thumb, the max_new_tokens should always be less than or equal to the max_length parameter. Why? Think about it..Step 8 : Create a chain for invoking the LLM.We have everything we want for our RAG application, last thing we need to do is to create a chain for invoking the LLM on our query to generate the response. There are different types of chains for the different types of use cases, if you like your LLM to remember the context of the chat over the time like the ChatGPT , you would need a memory instance which can be shared among multiple conversation pieces, for such cases, there are conversational chains available.For now we just need a chain which can combine our retrieved contexts and pass it with the query to the LLM to generate the response.rag_chain = (    {\"context\": retriever,  \"query\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())We have our Prompt, model, context and the query! All of them are combined into a single chain. It‚Äôs pretty much what all the chains does! Now before running the final code, I want to give a quick check on these two helper functions: RunnablePassthrough() and StrOutputParser().The RunnablePassthrough class in LangChain serves to pass inputs unchanged or with additional keys. In our chain, a prompt expects input in the form of a map with keys ‚Äúcontext‚Äù and ‚Äúquestion.‚Äù However, user input only includes the ‚Äúquestion.‚Äù or the ‚Äúquery‚Äù.  Here, RunnablePassthrough is utilized to pass the user‚Äôs question under the ‚Äúquestion‚Äù key while retrieving the context using a retriever. It just ensures that the input to the prompt conforms to the expected format.Secondally, StrOutputParser is typically employed in RAG chains to parse the output of the model into a human-readable string. In the layman terms, It is responsible for transforming the model‚Äôs output into a more coherent and grammatically correct sentence, which is generally better readable by Humans! That‚Äôs it!D-DayTo make sure we get the entire idea even if the response gets cut off, I‚Äôve implemented a function called get_complete_sentence(). Basically this function helps extract the last complete sentence from the text. So, even if the response hits the maximum token limit that we set upon and it gets truncated midway, we will still get a coherent understanding of the message.For practical testing, I suggest storing some low sized PDFs in the data folder of your project. You can choose PDFs related to various topics or domains that you want the chatbot to interact with. Additionally, providing a URL as a reference for the chatbot can be helpful for testing. For example, you could use a Wikipedia page, a research paper, or any other online document relevant to your testing goals. During my testing, I used a URL containing information about Jon Snow from Game of Thrones,  and PDFs of Transformers paper, and the YOLO V7 paper to evaluate the bot‚Äôs performance. Let‚Äôs see how our bot performs in varied content.import osfrom dotenv import load_dotenvfrom langchain.llms import HuggingFaceHubfrom langchain.embeddings import HuggingFaceInferenceAPIEmbeddingsfrom langchain.text_splitter import RecursiveCharacterTextSplitterfrom langchain_community.vectorstores import FAISSfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain.document_loaders import PyPDFLoaderfrom langchain.document_loaders import DirectoryLoader# Loading the environment variablesload_dotenv()HF_TOKEN = os.getenv(\"HUGGINGFACEHUB_API_TOKEN\")# Loading the web url and breaking down the information into chunksloader = WebBaseLoader(\"https://gameofthrones.fandom.com/wiki/Jon_Snow\")documents_loader = DirectoryLoader('../data/', glob=\"./*.pdf\", loader_cls=PyPDFLoader)# URL loaderurl_docs = loader.load()# Document loaderdata_docs = documents_loader.load()# Combining all the information into single variabledocs = url_docs + data_docstext_splitter = RecursiveCharacterTextSplitter(chunk_size = 1000, chunk_overlap = 50)documents = text_splitter.split_documents(docs)# Creating the embeddings objectembeddings = HuggingFaceInferenceAPIEmbeddings(    api_key=HF_TOKEN, model_name=\"BAAI/bge-base-en-v1.5\")# Creating a vectorstore objectvectorstore = FAISS.from_documents(documents, embeddings)# Defining a retriever retriever = vectorstore.as_retriever(search_type = \"mmr\", search_kwargs={\"k\": 3})# Model architecturemodel =  HuggingFaceHub(    repo_id=\"huggingfaceh4/zephyr-7b-alpha\",    model_kwargs={\"temperature\": 0.5, \"max_length\": 4096 ,\"max_new_tokens\": 2048 })template = \"\"\"Question : {query}\"\"\"prompt = ChatPromptTemplate.from_template(template)rag_chain = (    {\"context\": retriever,  \"query\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())def get_complete_sentence(response):    \"\"\"    Extracts the last complete sentence from a given text.        Args: response (str): The input text from which the last complete     sentence will be extracted.        Returns: str: The last complete sentence found in the input text.     If no complete sentence is found, returns the entire input text.    \"\"\"    # Find the last occurrence of a period (.)    last_period_index = response.rfind('.')     # If a period is found, return the text up to that point    if last_period_index != -1: return response[:last_period_index + 1]          # If no period is found, return the entire response    else: return response          # Invoke the RAG chain and retrieve the responseresponse = rag_chain.invoke(\"Who killed Jon Snow?\")# Get the complete sentencecomplete_sentence = get_complete_sentence(response)print(complete_sentence)This is the response I received after 10 seconds, which is quite good. The time it takes can vary depending on your system‚Äôs configuration, but I believe you‚Äôll get decent results in just a few minutes. So, please be patient if it‚Äôs taking a bit longer.Human: Question : Who killed Jon Snow?Answer: In the TV series Game of Thrones, Jon Snow was stabbed by his fellow Night's Watch members in season 5, episode 9, \"The Dance of Dragons.\" However, he was later resurrected by Melisandre in season 6, episode 3, \"Oathbreaker.\" So, technically, no one killed Jon Snow in the show.Have fun experimenting with various data sources! You can try changing the website addresses, adding new PDF files or maybe change the template a bit. LLMs are fun, you never know what you get!What‚Äôs next?There are plenty of things we can adjust here. We could switch to a more effective embedding model for better indexing, try different searching techniques for the retriever, add a reranker to improve the ranking of documents, or use a more advanced LLM with a larger context window and faster response times. Essentially, every RAG application is just an enhanced version based on these factors. However, the fundamental concept of how RAG applications function always stays the same.",
            "content_html": "<p><img src=\"https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/cat.png?raw=true\" alt=\"cat\" /></p><p><em>If you‚Äôre considering making a personalized bot for your documents or your website that responds to you, you‚Äôre in the right spot. I‚Äôm here to help you create a bot using Langchain and RAG strategies for this purpose.</em></p><h3 id=\"understanding-the-limitations-of-chatgpt-and-llms\">Understanding the Limitations of ChatGPT and LLMs</h3><p>ChatGPTs and other Large Language Models (LLMs) are extensively trained on text corpora to comprehend language semantics and coherence. Despite their impressive capabilities, these models have limitations that require careful consideration for particular use cases. One significant challenge is the potential for hallucinations, where the model might generate inaccurate or contextually irrelevant information.</p><p>Imagine requesting the model to enhance your company policies; in such scenarios, ChatGPTs and other Large Language Models might struggle to provide factual responses because they lack training on your company‚Äôs data. Instead, they may generate nonsensical or irrelevant responses, which can be unhelpful. So, how can we ensure that an LLM comprehends our specific data and generates responses accordingly? This is where techniques like Retrieval Augmentation Generation (RAG) come to the rescue.</p><p><img src=\"https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/LLM_without_RAG.png?raw=true\" alt=\"RAG\" /></p><h3 id=\"what-is-rag\">What is RAG?</h3><p>RAG or Retrieval Augmented Generation uses three main workflows to generate and give the better response</p><ul>  <li>    <p>Information Retrieval: When a user asks a question, the AI system retrieves the relevant data from a well-maintained knowledge library or external sources like databases, articles, APIs, or document repositories. This is achieved by converting the query into a numerical format or vector that can be understood by machines.</p>  </li>  <li>    <p>LLM: The retrieved data is then presented to the LLM or Large Language Model, along with the user‚Äôs query. The LLM uses this new knowledge and its training data to generate the response.</p>  </li>  <li>    <p>Response: Finally, the LLM generates a response that is more accurate and relevant since it has been augmented with the retrieved information. I mean we gave LLM some additional information from our Knowledge library which allows LLMs to provide more contextually relevant and factual responses, solving the problem of models when they are just hallucinating or providing irrelevant answer.</p>  </li></ul><p>Let‚Äôs take the example of company policies again. Suppose you have an HR bot that handles queries related to your Company policies. Now if someones asks anything specific to the policies, The bot can pull the most recent policy documents from the knowledge libray, pass the relevant context to a well crafted prompt which is then passed further to the LLM for generating the response.</p><p>To make it more easy, Imagine a LLM as your knowledgeable friend who seems to know everything, from Geography to Computer Science from Politics to Philosophy. Now, picture yourself asking this friend a few questions:</p><ul>  <li>‚ÄúWho handles my laundry on weekends?‚Äù</li>  <li>‚ÄúWho lives next door to me?‚Äù</li>  <li>‚ÄúWhat brand of peanut butter do I prefer?‚Äù</li></ul><p>Chances are, your friend wouldn‚Äôt be able to answer these questions. Most of the time, no. But let‚Äôs say this distant friend becomes closer to you over time, he comes at your place regularly, know your parents very well, you both hangout pretty often, you go on outings, blah blah blah.. You got the point.</p><p>I mean he is gaining access to personal and insider information about you.  Now, when you pose the same questions, he can somehow answer those question with more relevance now because because he is better suited with your personal insights.</p><p>Similarly, a LLM, when provided with additional information or access to your data, it won‚Äôt guess or hallucinate. Instead, it can leverage that data to provide more relevant and accurate answers.</p><h3 id=\"to-break-it-down-here-are-the-exact-steps-to-create-any-rag-application\">To break it down, here are the exact steps to create any RAG application‚Ä¶</h3><ol>  <li>Extract the relevant information from your data sources.</li>  <li>Break the information into the small chunks.</li>  <li>Store the chunks as their embedddings into a vector database.</li>  <li>Create a prompt template which will be fed to the LLM with the query and the context.</li>  <li>Convert the query to it‚Äôs relevant embedding using same embedding model.</li>  <li>Fetch k number of relevant documents related to the query from the vector database.</li>  <li>Pass the relevant documents to the LLM and get the response.</li></ol><h3 id=\"faqs\">FAQs</h3><ol>  <li>    <p>We will be using <a href=\"https://python.langchain.com/docs/get_started/introduction\">Langchain</a> for this task, Basically it‚Äôs like a wrapper which lets you talk and manage to your LLM operations better.</p>  </li>  <li>    <p>Along with it we will be using <a href=\"https://huggingface.co/\">Hugging Face</a>,  it  an open-source library for building, training, and deploying state-of-the-art machine learning models, especially about NLP. To use the HuggingFace we need the access token, Get your access token <a href=\"https://huggingface.co/docs/hub/security-tokens\">here</a></p>  </li>  <li>    <p>For our models, we‚Äôll need two key components: a LLM (Large Language Model) and an embedding model. While paid sources like OpenAI offer these, we‚Äôll be utilizing open-source models to ensure accessibility for everyone.</p>  </li>  <li>    <p>To keep things simple, our data ingestion process will involve using a URL and some PDFs. While you can incorporate additional data sources if needed, we‚Äôll concentrate solely on these two for now.</p>  </li></ol><p>With Langchain for the interface, Hugging Face for fetching the models, along with open-source components, we‚Äôre all set to go! This way, we will save some bucks while still having everything we need. Let‚Äôs move to the next steps</p><h3 id=\"environment-setup\">Environment Setup</h3><p>Open your favorite editor, create a python environment and install the relevant dependencies</p><pre><code class=\"language-python\">python3 -m venv envsource env/bin/activatepip3 install dotenv langchain langchain_community </code></pre><p>Now create a .env file in the same directory to place your Hugging Face api credentials like this</p><pre><code class=\"language-python\">HUGGINGFACEHUB_API_TOKEN = hf_KKNWfBqgwCUOHdHFrBwQ.....</code></pre><p>Ensure the name ‚ÄúHUGGINGFACEHUB_API_TOKEN‚Äù remains unchanged, as it is crucial for authentication purposes.</p><p>Finally create a data folder in the project‚Äôs root directory, designated as the central repository for storing PDF documents. You can add some sample PDFs for testing purposes; for instance, I am using the <a href=\"https://arxiv.org/pdf/2207.02696.pdf\">Yolo V7</a> and <a href=\"https://arxiv.org/abs/1706.03762\">Transformers</a> paper for demonstration. It‚Äôs important to note that this designated folder will function as our primary source for data ingestion.</p><p>It seems like everything is in order, and we‚Äôre all set!</p><h3 id=\"step-1--extracting-the-relevant-information\">Step 1 : Extracting the relevant information</h3><p>To get your RAG application running, the first thing we need to do is to extract the relevant information from the various data sources. It can be a website page, a PDF file, a notion link, a google doc whatever it is, it needs to be extracted from it‚Äôs original source first.</p><pre><code class=\"language-python\">from langchain.document_loaders import PyPDFLoaderfrom langchain_community.document_loaders import WebBaseLoader# Loading the environment variablesload_dotenv()HF_TOKEN = os.getenv(\"HUGGINGFACEHUB_API_TOKEN\")# Loading the web url and data url_loader = WebBaseLoader(\"https://docs.smith.langchain.com/overview\")documents_loader = DirectoryLoader('../data/', glob=\"./*.pdf\", loader_cls=PyPDFLoader)# Creating the instancesurl_docs = url_loader.load()data_docs = documents_loader.load()# Combining all the data that we ingesteddocs = url_docs + data_docs</code></pre><p>This will ingest all the data from the URL link and the PDFs.</p><h3 id=\"step-2--breaking-the-information-into-smaller-chunks\">Step 2 : Breaking the information into smaller chunks</h3><p>We‚Äôve all the necessary data for developing our RAG application. Now, it‚Äôs time to break down this information into smaller chunks. Later, we‚Äôll utilize an embedding model to convert these chunks into their respective embeddings. But why it‚Äôs important?</p><p>Think of it like this: If you‚Äôre tasked with digesting a 100-page book all at once and then asked a specific question about it, it would be challenging to retrieve the necessary information from the entire book to provide an answer. However, if you‚Äôre permitted to break the book into smaller, manageable chunks‚Äîlet‚Äôs say 10 pages each‚Äîand each chunk is labeled with an index from 0 to 9, the process becomes much simpler. When the same question is posed after this breakdown, you can easily locate the relevant chunk based on its index and then extract the information needed to answer the question accurately.</p><p>Picture the book as your extracted information, with each 10-page segment representing a small chunk of data, and the index as the embedding. Essentially, we‚Äôll apply an embedding model to these chunks to transform the information into their respective embeddings. While as humans, we may not directly comprehend or relate to these embeddings, they serve as numeric representations of the chunks to our application.  This is how you can do this in Python</p><pre><code class=\"language-python\">from langchain.text_splitter import RecursiveCharacterTextSplittertext_splitter = RecursiveCharacterTextSplitter(chunk_size = 1000, chunk_overlap = 50)documents = text_splitter.split_documents(docs)</code></pre><p>Now the chunk_size parameter specifies the maximum number of characters that a chunk can contain, while the chunk_overlap parameter specifies the number of characters that should overlap between two adjacent chunks. With the chunk_overlap set to 50, the last 50 characters of the adjacent chunks will be shared between each other.</p><p>This approach helps to prevent important information from being split across two chunks, ensuring that each chunk contains sufficient contextual information for the subsequent processing or analysis. As the shared information at the boundary of neighboring chunks enables a more seamless transition and understanding of the text‚Äôs content. The best strategy for choosing the chunk_size and chunk_overlap parameters largely depends on the nature of the documents and the purpose of the application.</p><h3 id=\"step-3--creating-the-embeddings-and-store-them-into-a-vectordatabase\">Step 3 : Creating the embeddings and store them into a vectordatabase</h3><p>We have two ways to generate the embeddings for these chunks. First, we can download a model, handle preprocessing and do computations on our own. Or, we can use Hugging Face‚Äôs model hub. They‚Äôve got lots of pre-trained models for different NLP tasks, including embedding generation.</p><p>With this approach, we‚Äôll use one of their embedding models where we‚Äôll just give our chunks to this model, and Hugging Face‚Äôs servers will do the hard work like preprocessing and computing. This saves us from burning our own machines for those heavy computations. üíÄ</p><p>We have a bunch of options for embedding models, and you can check out the leaderboard <a href=\"https://huggingface.co/spaces/mteb/leaderboard\">here</a> and choose best one for your compatibility. But for now, we‚Äôll go with ‚Äúbge-base-en-v1.5‚Äù. It‚Äôs great for generating embeddings for English text, plus it‚Äôs smaller, so it loads quickly and gets the job done fast.</p><pre><code class=\"language-python\">from langchain.embeddings import HuggingFaceInferenceAPIEmbeddings# Creating the embeddings objectembeddings = HuggingFaceInferenceAPIEmbeddings(    api_key=HF_TOKEN, model_name=\"BAAI/bge-base-en-v1.5\")</code></pre><p>Here‚Äôs a way to see the number of embeddings for each chunk</p><pre><code class=\"language-python\">query = \"Hello I want to see the length of the embeddings for this document.\"embeddings.embed_documents([query])[0]# 768</code></pre><p>We have the embeddings for our chunks, now we need a vector database to store them. When it comes to vector databases, there are plenty of options out there.</p><p>DB like Pinecone are paid but offer fast performance and extra features compared to open-source alternatives like FAISS or Chroma. However, if you don‚Äôt need to scale your database to handle hundreds of users fetching and storing data every minute, open-source options are more than enough. Instead, they work really well. So, what we‚Äôll do we‚Äôll create  an instance of FAISS vector database and store our embeddings in it. It‚Äôs straightforward and doesn‚Äôt require any rocket science.</p><pre><code class=\"language-python\">from langchain_community.vectorstores import FAISS# Creating a vectorstore objectvectorstore = FAISS.from_documents(documents, embeddings)</code></pre><h3 id=\"step-4--create-a-prompt-template-which-will-be-fed-to-the-llm\">Step 4 : Create a prompt template which will be fed to the LLM</h3><p>Ok now comes the prompt template. So when you write a question to the ChatGPT and it answers that question, you are basically providing a prompt to the model so that it can understand what‚Äôs the question is. When companies train the models, they decide what kind of prompt they are going to use for invoking the model and ask the question. For example, if you are working with ‚ÄúMistral 7B instruct‚Äù and you want the optimal results it‚Äôs recommended to use the following chat template:</p><pre><code class=\"language-python\">&lt;s&gt;[INST] Instruction [/INST] Model answer&lt;/s&gt;[INST] Follow-up instruction [/INST]</code></pre><p>Note that &lt;s&gt; and &lt;/s&gt; are special tokens to represent beginning of string (BOS) and end of string (EOS) while [INST] and [/INST] are regular strings. It‚Äôs just that the Mistral 7B instruct is made in such a way that the model look for those special tokens to understand the question better. Different types of LLMs have different kinds of instructed prompts.</p><p>Now for our case we are going to use <a href=\"https://huggingface.co/HuggingFaceH4/zephyr-7b-alpha\">huggingfaceh4/zephyr-7b-alpha</a> which is a text generation model. Just to make it clear, Zephyr-7B-Œ± has not been aligned or formated to human preferences with techniques like RLHF (Reinforcement Learning with Human Feedback) or deployed with in-the-loop filtering of responses like ChatGPT, so the model can produce problematic outputs (especially when prompted to do so).</p><p>Instead of writing a Prompt of our own, I will use ChatPromptTemplate class which creates a prompt template for the chat models. In layman terms, instead of writing a specified prompt I am letting ChatPromptTemplate to do it for me. Here is an example prompt template that is being generated from the manual messsages.</p><pre><code class=\"language-python\">from langchain_core.prompts import ChatPromptTemplatechat_template = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful AI bot. Your name is {name}.\"),        (\"human\", \"Hello, how are you doing?\"),        (\"ai\", \"I'm doing well, thanks!\"),        (\"human\", \"{user_input}\"),    ])messages = chat_template.format_messages(name=\"Bob\", user_input=\"What is your name?\")</code></pre><p>If you don‚Äôt want to write the manual instructions, you can just use the <em>from_template</em> function to generate a more generic prompt template which I used for this project. Here it is..</p><pre><code class=\"language-python\">from langchain_core.prompts import ChatPromptTemplatetemplate = \"\"\"{query}\"\"\"prompt = ChatPromptTemplate.from_template(template)</code></pre><p>Our prompt is set! We‚Äôve crafted a single message, assuming it‚Äôs from a human xD . If you‚Äôre not using the from_messages function, the ChatPromptTemplate will ensure your prompt works seamlessly with the language model by reserving some additional system messages. While there‚Äôs always room for improvement with more generic prompts to achieve better results, this setup should work for now!</p><h3 id=\"step-5--convert-the-query-to-its-relevant-embedding-using-same-embedding-model\">Step 5 : Convert the query to it‚Äôs relevant embedding using same embedding model.</h3><p>Now, let‚Äôs talk about the query or question we want to ask our RAG application. We can‚Äôt just pass the query to our model and expect information in return. Instead, we need to pass the query through the same embedding model used for the chunks earlier. Why is this important? Well, by embedding queries, we allow models to compare them efficiently with previously processed chunks of text. This enables tasks like finding similar documents or generating relevant responses.</p><p>It‚Äôs like translating language into a language computers understand. Imagine you‚Äôre an English speaker and your friend speaks Hindi. Neither of you understands each other‚Äôs language. You hand your English-speaking friend a one-page document written in Hindi. Your friend has to translate that document into English before they can understand it‚Äôs content. Now, if you ask a question in Hindi related to that document, your friend has to translate the question into English first to understand it, and then find a relevant response from the information you shared earlier. In this scenario, your friend acts like an embedding model. He converted your previous texts into the relevant language or embeddings if I say.</p><p>Now, when you ask a query or question, it will be translated into the relevant embeddings using the same embedding model used for the chunks. Then, a search operation will be performed to find the relevant response to your query. I hope this clarifies why we converted our query into embeddings first.</p><h3 id=\"step-6--fetch-k-number-of-documents\">Step 6 : Fetch K number of documents.</h3><p>Now, let‚Äôs talk about the retriever. Its job is to dive into the vector database and perform a search to find relevant documents. It returns a set number, let‚Äôs call it ‚Äúk‚Äù, of these documents, which are ranked based on their contextual relevance to the query or question you asked. You can set ‚Äúk‚Äù as a parameter, indicating how many relevant documents you want - whether it‚Äôs 2, 5, or 10. Generally, if you have a smaller amount of data, it‚Äôs best to stick with a lower ‚Äúk‚Äù, around 2. For longer documents or larger datasets, a ‚Äúk‚Äù between 10 and 20 is recommended.</p><p>Different <a href=\"https://python.langchain.com/docs/modules/data_connection/retrievers/vectorstore\">search techniques</a> can be employed to fetch relevant documents more effectively and quickly from a vector database. The choice depends on various factors such as your specific use case, the amount of data you have, what kind of vector database you are using and the context of your problem.</p><pre><code class=\"language-python\">retriever = vectorstore.as_retriever(search_type = \"mmr\", search_kwargs={\"k\": 3})docs = retriever.get_relevant_documents(\"what did you know about Yolo V7?\")print(docs)</code></pre><p>When you run this code, the retriever will fetch 3 most most relevant documents from the vector database based on the mmr search criteria. All these documents will be the contexts for our LLM model to generate the response for our query.</p><h3 id=\"step-7--pass-the-relevant-documents-to-the-llm-and-get-the-response\">Step 7 : Pass the relevant documents to the LLM and get the response.</h3><p>So far, we‚Äôve asked our retriever to fetch a set number of relevant documents from the database. Now, we need a language model (LLM) to generate a relevant response based on that context. To ensure robustness, let‚Äôs remember that at the beginning of this blog, I mentioned that LLMs like ChatGPT can sometimes generate irrelevant responses, especially when asked about specific use cases or contexts. However, this time, we‚Äôre providing the context from our own data to the LLM as a reference. So, it will consider this reference along with its general capabilities to answer the question. That‚Äôs the whole idea behind using RAG!</p><p>Now, let‚Äôs dive into implementing the language model (LLM) aspect of our RAG setup. We‚Äôll be using zephyr model architecture from the Hugging Face Hub. Here‚Äôs how we do it in Python:</p><pre><code class=\"language-python\">from langchain.llms import HuggingFaceHub# Model architecturemodel =  HuggingFaceHub(    repo_id=\"huggingfaceh4/zephyr-7b-alpha\",    model_kwargs={\"temperature\": 0.5, \"max_length\": 4096 ,\"max_new_tokens\": 2048 })</code></pre><p>In this code snippet, we‚Äôre instantiating our language model using the Hugging Face Hub. Specifically, we‚Äôre selecting the zephyr 7 billion model which is placed in this repository ID <a href=\"https://huggingface.co/HuggingFaceH4/zephyr-7b-alpha\">‚Äúhuggingfaceh4/zephyr-7b-alpha‚Äù</a>. Choice of choosing this model isn‚Äôt arbitrary; as I said before, it‚Äôs based on the model‚Äôs suitability for our specific task and requirements. As we are already implementing only Open Source components, Zephyr 7 billion works good enough to generate the useful response with minimal overhead and low latency.</p><p>This model comes with some additional parameters to fine-tune its behavior. We‚Äôve set the temperature to 0.5, which controls the randomness of the generated text. As a lower temperature tends to result in more conservative and predictable outputs and    when the temperature is set to max which is 1, the model tries to be as much creative as it could, so based on what type of output you want for your use case, you can tweak this parameter. For the sake of the simplicity and demonstration purposes, I set it to 0.5 to make sure we get decent results. Next is max_length parameter which defines the maximum length of the generated text and it includes the size of your prompt as well as the response.</p><p>max_new_tokens sets the threshold on maximum number of new tokens that can be generated. As a general rule of thumb, the max_new_tokens should always be less than or equal to the max_length parameter. Why? Think about it..</p><h3 id=\"step-8--create-a-chain-for-invoking-the-llm\">Step 8 : Create a chain for invoking the LLM.</h3><p>We have everything we want for our RAG application, last thing we need to do is to create a chain for invoking the LLM on our query to generate the response. There are different types of chains for the different types of use cases, if you like your LLM to remember the context of the chat over the time like the ChatGPT , you would need a memory instance which can be shared among multiple conversation pieces, for such cases, there are conversational chains available.</p><p>For now we just need a chain which can combine our retrieved contexts and pass it with the query to the LLM to generate the response.</p><pre><code class=\"language-python\">rag_chain = (    {\"context\": retriever,  \"query\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())</code></pre><p>We have our Prompt, model, context and the query! All of them are combined into a single chain. It‚Äôs pretty much what all the chains does! Now before running the final code, I want to give a quick check on these two helper functions: <code>RunnablePassthrough()</code> and <code>StrOutputParser()</code>.</p><p>The <code>RunnablePassthrough</code> class in <code>LangChain</code> serves to pass inputs unchanged or with additional keys. In our chain, a prompt expects input in the form of a map with keys ‚Äúcontext‚Äù and ‚Äúquestion.‚Äù However, user input only includes the ‚Äúquestion.‚Äù or the ‚Äúquery‚Äù.  Here, <code>RunnablePassthrough</code> is utilized to pass the user‚Äôs question under the ‚Äúquestion‚Äù key while retrieving the context using a retriever. It just ensures that the input to the prompt conforms to the expected format.</p><p>Secondally, <code>StrOutputParser</code> is typically employed in RAG chains to parse the output of the model into a human-readable string. In the layman terms, It is responsible for transforming the model‚Äôs output into a more coherent and grammatically correct sentence, which is generally better readable by Humans! That‚Äôs it!</p><h3 id=\"d-day\">D-Day</h3><p><img src=\"https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/LLM_with_RAG.png?raw=true\" alt=\"With_RAG\" /></p><p>To make sure we get the entire idea even if the response gets cut off, I‚Äôve implemented a function called <code>get_complete_sentence()</code>. Basically this function helps extract the last complete sentence from the text. So, even if the response hits the maximum token limit that we set upon and it gets truncated midway, we will still get a coherent understanding of the message.</p><p>For practical testing, I suggest storing some low sized PDFs in the data folder of your project. You can choose PDFs related to various topics or domains that you want the chatbot to interact with. Additionally, providing a URL as a reference for the chatbot can be helpful for testing. For example, you could use a Wikipedia page, a research paper, or any other online document relevant to your testing goals. During my testing, I used a URL containing information about Jon Snow from Game of Thrones,  and PDFs of Transformers paper, and the YOLO V7 paper to evaluate the bot‚Äôs performance. Let‚Äôs see how our bot performs in varied content.</p><pre><code class=\"language-python\">import osfrom dotenv import load_dotenvfrom langchain.llms import HuggingFaceHubfrom langchain.embeddings import HuggingFaceInferenceAPIEmbeddingsfrom langchain.text_splitter import RecursiveCharacterTextSplitterfrom langchain_community.vectorstores import FAISSfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain.document_loaders import PyPDFLoaderfrom langchain.document_loaders import DirectoryLoader# Loading the environment variablesload_dotenv()HF_TOKEN = os.getenv(\"HUGGINGFACEHUB_API_TOKEN\")# Loading the web url and breaking down the information into chunksloader = WebBaseLoader(\"https://gameofthrones.fandom.com/wiki/Jon_Snow\")documents_loader = DirectoryLoader('../data/', glob=\"./*.pdf\", loader_cls=PyPDFLoader)# URL loaderurl_docs = loader.load()# Document loaderdata_docs = documents_loader.load()# Combining all the information into single variabledocs = url_docs + data_docstext_splitter = RecursiveCharacterTextSplitter(chunk_size = 1000, chunk_overlap = 50)documents = text_splitter.split_documents(docs)# Creating the embeddings objectembeddings = HuggingFaceInferenceAPIEmbeddings(    api_key=HF_TOKEN, model_name=\"BAAI/bge-base-en-v1.5\")# Creating a vectorstore objectvectorstore = FAISS.from_documents(documents, embeddings)# Defining a retriever retriever = vectorstore.as_retriever(search_type = \"mmr\", search_kwargs={\"k\": 3})# Model architecturemodel =  HuggingFaceHub(    repo_id=\"huggingfaceh4/zephyr-7b-alpha\",    model_kwargs={\"temperature\": 0.5, \"max_length\": 4096 ,\"max_new_tokens\": 2048 })template = \"\"\"Question : {query}\"\"\"prompt = ChatPromptTemplate.from_template(template)rag_chain = (    {\"context\": retriever,  \"query\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())def get_complete_sentence(response):    \"\"\"    Extracts the last complete sentence from a given text.        Args: response (str): The input text from which the last complete     sentence will be extracted.        Returns: str: The last complete sentence found in the input text.     If no complete sentence is found, returns the entire input text.    \"\"\"    # Find the last occurrence of a period (.)    last_period_index = response.rfind('.')     # If a period is found, return the text up to that point    if last_period_index != -1: return response[:last_period_index + 1]          # If no period is found, return the entire response    else: return response          # Invoke the RAG chain and retrieve the responseresponse = rag_chain.invoke(\"Who killed Jon Snow?\")# Get the complete sentencecomplete_sentence = get_complete_sentence(response)print(complete_sentence)</code></pre><p>This is the response I received after 10 seconds, which is quite good. The time it takes can vary depending on your system‚Äôs configuration, but I believe you‚Äôll get decent results in just a few minutes. So, please be patient if it‚Äôs taking a bit longer.</p><pre><code class=\"language-python\">Human: Question : Who killed Jon Snow?Answer: In the TV series Game of Thrones, Jon Snow was stabbed by his fellow Night's Watch members in season 5, episode 9, \"The Dance of Dragons.\" However, he was later resurrected by Melisandre in season 6, episode 3, \"Oathbreaker.\" So, technically, no one killed Jon Snow in the show.</code></pre><p><img src=\"https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/cat2.png?raw=true\" alt=\"cat2\" /></p><p>Have fun experimenting with various data sources! You can try changing the website addresses, adding new PDF files or maybe change the template a bit. LLMs are fun, you never know what you get!</p><h3 id=\"whats-next\">What‚Äôs next?</h3><p>There are plenty of things we can adjust here. We could switch to a more effective embedding model for better indexing, try different searching techniques for the retriever, add a reranker to improve the ranking of documents, or use a more advanced LLM with a larger context window and faster response times. Essentially, every RAG application is just an enhanced version based on these factors. However, the fundamental concept of how RAG applications function always stays the same.</p>",
            "url": "http://localhost:4000/2024/02/07/rag-application-with-langchain",
            
            
            
            "tags": ["LLM","Deep Learning"],
            
            "date_published": "2024-02-07T00:00:00+05:30",
            "date_modified": "2024-02-07T00:00:00+05:30",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}