<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Blixxi Labs</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2024-05-21T00:09:12+05:30</updated>
 <id>http://localhost:4000</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>Create a Movie Recommendation System using RAG</title>
   <link href="http://localhost:4000/2024/05/17/movie-recommendation-system-with-vdb"/>
   <updated>2024-05-17T00:00:00+05:30</updated>
   <id>http://localhost:4000/2024/05/17/movie-recommendation-system-with-vdb</id>
   <content type="html">&lt;p&gt;This article provides a comprehensive guide on creating a scalable and production-grade movie recommendation system by leveraging the power of Genre Spectrum Embeddings and VectorDB. Inspired by the implementation outlined in this &lt;a href=&quot;https://arxiv.org/pdf/2309.08787&quot;&gt;paper&lt;/a&gt;, We’ll explore how combining these two techniques can significantly enhance the recommendation experience, addressing key challenges faced by traditional systems.&lt;/p&gt;

&lt;p&gt;Here’s what we cover below:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Introduction to Genre Spectrum Embeddings&lt;/li&gt;
  &lt;li&gt;Data Ingestion and preprocessing techniques for movie metadata&lt;/li&gt;
  &lt;li&gt;Generating embeddings using Doc2Vec&lt;/li&gt;
  &lt;li&gt;Extracting the unique genre labels&lt;/li&gt;
  &lt;li&gt;Training and Testing a Neural Network for genre_classification task&lt;/li&gt;
  &lt;li&gt;A movie recommendation system&lt;/li&gt;
  &lt;li&gt;Using Genre Spectrum Embeddings to get the relevant recommendations&lt;/li&gt;
  &lt;li&gt;Get the relevant recommendation for a given Movie&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s get started!&lt;/p&gt;

&lt;h2 id=&quot;introduction-to-genre-spectrum-embeddings&quot;&gt;Introduction to Genre Spectrum Embeddings&lt;/h2&gt;

&lt;p&gt;Scrolling through streaming platforms can be frustrating when the movie suggestions don’t match our interests. Building recommendation systems is a complex task as there isn’t one metric that can measure the quality of recommendations. To improve this, we propose combining Genre Spectrum Embeddings and VectorDB for better recommendations.&lt;/p&gt;

&lt;p&gt;The Genre Spectrum approach involves combining the various movie genres or characteristics of a movie to form Initial embeddings, which offer a comprehensive portrayal of the movie content. Then these embeddings are used as a input to train a Deep Learning model producing Genre Spectrum embeddings at the penultimate layer.&lt;/p&gt;

&lt;p&gt;These embeddings serve dual purposes: they can either be directly inputted into a classification model for genre classification or stored in a VectorDB. By storing embeddings in a VectorDB, efficient retrieval and query search for recommendations become possible at a later stage. This architecture offers a holistic understanding of the underlying processes involved.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/movie-recommendation-using-rag/movie_recommendation_architecture.png?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-ingestion-and-preprocessing-techniques-for-movie-metadata&quot;&gt;Data Ingestion and preprocessing techniques for movie metadata&lt;/h2&gt;

&lt;p&gt;Our initial task involves gathering and organizing information about movies. This includes gathering extensive details such as the movie’s type, plot summary, genres, audience ratings, and more.&lt;/p&gt;

&lt;p&gt;Thankfully, we have access to a robust dataset on &lt;a href=&quot;https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset&quot;&gt;Kaggle&lt;/a&gt; containing information from various sources for approximately 45,000 movies. Please dowload the data from the Kaggle and place it inside your working directory. Watch for a file named &lt;code&gt;movies_metadata.csv&lt;/code&gt;. If you require additional data, you can supplement the dataset by extracting information from platforms like Rotten Tomatoes, IMDb, or even box-office records.&lt;/p&gt;

&lt;p&gt;Our next step is to extract the core details from this dataset and generate a universal summary for each movie. Initially, I’ll combine the movie’s title, genre, and overview into a single textual string. Then, this text will be tagged to create TaggedDocument instances, which will be utilized to train the Doc2Vec model later on.&lt;/p&gt;

&lt;p&gt;Before moving forward, let’s install the relevant libraries to make our life easier..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;pip install torch scikit-learn pylance lancedb nltk gensim lancedb scipy==1.12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we’ll proceed with the ingestion and preprocessing of the data. To simplify the process, we’ll work with chunks of 1000 movies at a time. For clarity, I’ll only include movie indices with non-null values for genres, accurate titles, and complete overviews, this approach ensures that we’re working with high-quality, relevant data for our analysis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from nltk import word_tokenize
from torch.utils.data import DataLoader, TensorDataset
from gensim.models.doc2vec import Doc2Vec, TaggedDocument
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.model_selection import train_test_split
from tqdm import tqdm

import nltk
nltk.download(&apos;punkt&apos;)

# Read data from CSV file
movie_data = pd.read_csv(&apos;movies_metadata.csv&apos;, low_memory=False)
device = torch.device(&apos;cuda&apos; if torch.cuda.is_available() else &apos;cpu&apos;)

def preprocess_data(movie_data_chunk):
    tagged_docs = []
    valid_indices = []
    movie_info = []

    # Wrap your loop with tqdm
    for i, row in tqdm(movie_data_chunk.iterrows(), total=len(movie_data_chunk)):
        try:
            # Constructing movie text
            movies_text = &apos;&apos;
            genres = &apos;, &apos;.join([genre[&apos;name&apos;] for genre in eval(row[&apos;genres&apos;])])
            movies_text += &quot;Genres: &quot; + genres + &apos;\n&apos;
            movies_text += &quot;Title: &quot; + row[&apos;title&apos;] + &apos;\n&apos;
            tagged_docs.append(TaggedDocument(words=word_tokenize(movies_text.lower()), tags=[str(i)]))
            valid_indices.append(i)
            movie_info.append((row[&apos;title&apos;], genres))
        except Exception as e:
            continue

    return tagged_docs, valid_indices, movie_info

# Preprocess data and extract genres for the first 1000 movies
chunk_size = 1000
tagged_data = []
valid_indices = []
movie_info = []
for chunk_start in range(0, len(movie_data), chunk_size):
    movie_data_chunk = movie_data.iloc[chunk_start:chunk_start+chunk_size]
    chunk_tagged_data, chunk_valid_indices, chunk_movie_info = preprocess_data(movie_data_chunk)
    tagged_data.extend(chunk_tagged_data)
    valid_indices.extend(chunk_valid_indices)
    movie_info.extend(chunk_movie_info)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;generating-embeddings-using-doc2vec&quot;&gt;Generating embeddings using Doc2Vec&lt;/h2&gt;

&lt;p&gt;Next, we’ll utilize the Doc2Vec model to generate embeddings for each movie based on the preprocessed text. We’ll allow the Doc2Vec model to train for several epochs to capture the essence of the various movies and their metadata in the multidimensional latent space. This process will help us represent each movie in a way that captures its unique characteristics and context.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def train_doc2vec_model(tagged_data, num_epochs=10):
    doc2vec_model = Doc2Vec(vector_size=100, min_count=2, epochs=num_epochs)
    doc2vec_model.build_vocab(tqdm(tagged_data, desc=&quot;Building Vocabulary&quot;))
    for epoch in range(num_epochs):
        doc2vec_model.train(tqdm(tagged_data, desc=f&quot;Epoch {epoch+1}&quot;), total_examples=doc2vec_model.corpus_count, epochs=doc2vec_model.epochs)
    
    return doc2vec_model

doc2vec_model = train_doc2vec_model(tagged_data)
doc2vec_model.save(&quot;doc2vec_model&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;train_doc2vec_model&lt;/code&gt; function trains a Doc2Vec model on the tagged movie data, producing 100-dimensional embeddings for each movie. These embeddings act as input features for the subsequent neural network, which we’ll employ to generate the &lt;code&gt;genre_embeddings&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Up to this point, we’ve gathered sufficient metadata for movies and consolidated genres, overviews, and titles. Then, leveraging the Doc2Vec model, we’ve generated meaningful representations of the movies based on their relevance.&lt;/p&gt;

&lt;p&gt;Essentially, our Doc2Vec model has produced vectors and positioned them in a multidimensional space so that similar movies are closer to each other in the latent space. With our current training setup we are sure that the movies with identical genres and similar overviews will be positioned closer to each other in this space, reflecting their thematic and content similarities.&lt;/p&gt;

&lt;h2 id=&quot;extracting-the-unique-genre-labels&quot;&gt;Extracting the unique genre labels&lt;/h2&gt;

&lt;p&gt;Next, our focus shifts to compiling the names of relevant movies along with their genres. Subsequently, we’ll employ a tool called &lt;code&gt;MultiLabelBinarizer&lt;/code&gt; to transform these genres into a more comprehensible format.&lt;/p&gt;

&lt;p&gt;To illustrate this, let’s consider a movie with three genres: ‘drama’, ‘comedy’, and ‘horror’. Using the &lt;code&gt;MultiLabelBinarizer&lt;/code&gt;, we’ll represent these genres with lists of 0s and 1s. If a movie belongs to a particular genre, it will be assigned a 1, and if it doesn’t, it will receive a 0. Consequently, each row in our dataset will indicate which genres are associated with a specific movie. This approach simplifies the genre representation for easier analysis.&lt;/p&gt;

&lt;p&gt;Let’s take the movie “Top Gun Maverick” as a reference. We’ll associate its genres using binary encoding. Suppose this movie is categorized only under ‘drama’, not ‘comedy’ or ‘horror’. When we apply the &lt;code&gt;MultiLabelBinarizer&lt;/code&gt; the representation would be: Drama: 1, Comedy: 0, Horror: 0. This signifies that “Top Gun Maverick” is classified as a drama but not as a comedy or horror.&lt;/p&gt;

&lt;p&gt;We’ll replicate this process for all the movies in our dataset to identify the unique genre labels present in our data.&lt;/p&gt;

&lt;h2 id=&quot;training-a-nn-for-genre_classification-task&quot;&gt;Training a NN for genre_classification task&lt;/h2&gt;

&lt;p&gt;We’ll define a class called GenreClassifier, which encapsulates a neural network consisting of four linear layers with ReLU activations. The final layer utilizes softmax activation to generate probability scores for various genres. If your objective is primarily classification within the Genre Spectrum, where you input a movie description to determine its relevant genres, you can establish a threshold value for the multi-label softmax output. This allows you to select the top ‘n’ genres with the highest probabilities.&lt;/p&gt;

&lt;p&gt;Here’s the NN class, hyperparameter settings, and the corresponding training loop for training our model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.model_selection import train_test_split

device = torch.device(&apos;cuda&apos; if torch.cuda.is_available() else &apos;cpu&apos;)

# Extract genre labels for the valid indices
genres_list = []
for i in valid_indices:
    row = movie_data.loc[i]
    genres = [genre[&apos;name&apos;] for genre in eval(row[&apos;genres&apos;])]
    genres_list.append(genres)

mlb = MultiLabelBinarizer()
genre_labels = mlb.fit_transform(genres_list)

embeddings = []
for i in valid_indices:
    embeddings.append(doc2vec_model.dv[str(i)])
X_train, X_test, y_train, y_test = train_test_split(embeddings, genre_labels, test_size=0.2, random_state=42)

X_train_np = np.array(X_train, dtype=np.float32)
y_train_np = np.array(y_train, dtype=np.float32)
X_test_np = np.array(X_test, dtype=np.float32)
y_test_np = np.array(y_test, dtype=np.float32)

X_train_tensor = torch.tensor(X_train_np)
y_train_tensor = torch.tensor(y_train_np)
X_test_tensor = torch.tensor(X_test_np)
y_test_tensor = torch.tensor(y_test_np)

class GenreClassifier(nn.Module):
    def __init__(self, input_size, output_size):
        super(GenreClassifier, self).__init__()
        self.fc1 = nn.Linear(input_size, 512)
        self.bn1 = nn.BatchNorm1d(512)
        self.fc2 = nn.Linear(512, 256)
        self.bn2 = nn.BatchNorm1d(256)
        self.fc3 = nn.Linear(256, 128)
        self.bn3 = nn.BatchNorm1d(128)
        self.fc4 = nn.Linear(128, output_size)
        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(p=0.2)  # Adjust the dropout rate as needed

    def forward(self, x):
        x = self.fc1(x)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc2(x)
        x = self.bn2(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc3(x)
        x = self.bn3(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc4(x)
        return x

# Move model to the selected device
model = GenreClassifier(input_size=100, output_size=len(mlb.classes_)).to(device)

# Define loss function and optimizer
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
epochs = 50
batch_size = 64

train_dataset = TensorDataset(X_train_tensor.to(device), y_train_tensor.to(device))
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)  # Move data to device
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item() * inputs.size(0)
    epoch_loss = running_loss / len(train_loader.dataset)
    print(f&apos;Epoch [{epoch + 1}/{epochs}], Loss: {epoch_loss:.4f}&apos;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it! We’ve successfully trained a Neural network for our genre classification task. You can check if the model is performing well  or not in terms of the genre classification.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from sklearn.metrics import f1_score

model.eval()
with torch.no_grad():
    X_test_tensor, y_test_tensor = X_test_tensor.to(device), y_test_tensor.to(device)  # Move test data to device
    outputs = model(X_test_tensor)
    test_loss = criterion(outputs, y_test_tensor)
    print(f&apos;Test Loss: {test_loss.item():.4f}&apos;)


thresholds = [0.1] * len(mlb.classes_) 
thresholds_tensor = torch.tensor(thresholds, device=device).unsqueeze(0)

# Convert the outputs to binary predictions using varying thresholds
predicted_labels = (outputs &amp;gt; thresholds_tensor).cpu().numpy()

# Convert binary predictions and actual labels to multi-label format
predicted_multilabels = mlb.inverse_transform(predicted_labels)
actual_multilabels = mlb.inverse_transform(y_test_np)

# Print the Predicted and Actual Labels for each movie
for i, (predicted, actual) in enumerate(zip(predicted_multilabels, actual_multilabels)):
    print(f&apos;Movie {i+1}:&apos;)
    print(f&apos;    Predicted Labels: {predicted}&apos;)
    print(f&apos;    Actual Labels: {actual}&apos;)


# Compute F1-score
f1 = f1_score(y_test_np, predicted_labels, average=&apos;micro&apos;)
print(f&apos;F1-score: {f1:.4f}&apos;)

# Saving the trained model
torch.save(model.state_dict(), &apos;trained_model.pth&apos;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, our next step is to take a query and generate the three most relevant genres based on our trained model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def test_model(movie_descriptions, doc2vec_model, model, mlb):
    tagged_docs = [TaggedDocument(words=word_tokenize(desc.lower()), tags=[str(i)]) for i, desc in enumerate(movie_descriptions)]
    embeddings = [doc2vec_model.infer_vector(doc.words) for doc in tagged_docs]
    X_test_np = np.array(embeddings, dtype=np.float32)
    X_test_tensor = torch.tensor(X_test_np).to(device)
    
    model.eval()
    with torch.no_grad():
        outputs = model(X_test_tensor)
    
    # Get top N genres with the highest probabilities
    N = 3  # Number of top genres to select
    top_n_indices = np.argsort(-outputs.cpu().numpy())[:, :3]
    predicted_genres = mlb.classes_[top_n_indices]

    return predicted_genres


# Example movie descriptions to test the model
example_movie_descriptions = [
    &quot;A young boy discovers a magical world filled with strange creatures and danger.&quot;,
    &quot;In a dystopian future, a group of rebels fights against an oppressive government.&quot;,
    &quot;A comedy about two people who meet on a train and embark on a whirlwind adventure.&quot;
]

test_model(example_movie_descriptions, doc2vec_model, model, mlb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I trained the network on CPU using the same hyperparameter configuration as mentioned, and here are the results I obtained.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;[[&apos;Drama&apos; &apos;Adventure&apos; &apos;Thriller&apos;]
 [&apos;Drama&apos; &apos;Action&apos; &apos;Thriller&apos;]
 [&apos;Drama&apos; &apos;Comedy&apos; &apos;Thriller&apos;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, we’ve developed a comprehensive architecture for classifying genres based on a given query. But brace yourself, because we’re about to delve into something more substantial.&lt;/p&gt;

&lt;p&gt;When it comes to genre_embeddings, we can extract them from the final linear layer, which serves as the penultimate layer of the neural network. This layer encapsulates the entire context for each movie. In other words, we can extract the weights from the last linear layer and create vectors from those weights. These vectors will somehow encapsulate the information that the neural network captured from our input, which was the Doc2Vec embeddings of our movies metadata.&lt;/p&gt;

&lt;p&gt;Following this, we can store these embeddings elsewhere, such as in a VectorDB, for future utilization. This setup allows us to conduct query searches and deliver better recommendations by leveraging the stored genre_embeddings.&lt;/p&gt;

&lt;h2 id=&quot;a-movie-recommendation-system&quot;&gt;A movie recommendation system&lt;/h2&gt;

&lt;p&gt;To build a movie recommendation system, we’ll allow users to input a movie name, and based on that, we’ll return relevant recommendations. To achieve this, we’ll save the genre_embeddings in a Vector Database. When a user inputs a query in the form of a new movie, we’ll first locate its genre_embeddings in our vector database. Once we have this, we’ll find ‘n’ number of movies whose genre_embeddings are similar to ours. We can assess the similarity using various search algorithms like cosine similarity or by finding the least Euclidean distance.&lt;/p&gt;

&lt;p&gt;For simplification, I’ve opted to use &lt;a href=&quot;https://lancedb.com/&quot;&gt;LanceDB&lt;/a&gt;, an open-source vector database known for its blazing speed, high-level security (since our data remains local), versioning, and built-in search capabilities. We’ll organize all the data into lists, with each list representing an individual movie. Subsequently, we’ll create a CSV file containing relevant data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def extract_genre_embeddings(model, X_data):
    model.eval()
    with torch.no_grad():
        embeddings = model.fc3(model.relu(model.fc2(model.relu(model.fc1(X_data.to(device))))))
    return embeddings.cpu().numpy()

train_embeddings = extract_genre_embeddings(model, X_train_tensor)
test_embeddings = extract_genre_embeddings(model, X_test_tensor)

# Combine training and test data
all_indices = valid_indices[:len(X_train_tensor)] + valid_indices[len(X_train_tensor):]
all_embeddings = np.concatenate((train_embeddings, test_embeddings), axis=0)
all_genres = np.concatenate((y_train_np, y_test_np), axis=0)

# Create a dataframe
movie_embeddings_df = pd.DataFrame({
    &apos;movie_index&apos;: all_indices,
    &apos;title&apos;: [movie_data.loc[idx, &apos;title&apos;] for idx in all_indices],
    &apos;genre_embeddings&apos;: [list(embeddings) for embeddings in all_embeddings],  # Convert each array of embeddings to a list
    &apos;genre_labels&apos;: [mlb.classes_[labels.nonzero()[0]] for labels in all_genres]
})

# Save the data as a csv file
movie_embeddings_df.to_csv(&quot;movie_embeddings.csv&quot;, index=False)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, introducing LanceDB!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import ast
import lancedb
import pandas as pd
from lancedb.pydantic import LanceModel, Vector

data = pd.read_csv(&quot;movie_embeddings.csv&quot;)
data.drop(columns=[&quot;movie_index&quot;], inplace=True)

movie_data = []
for index, row in data.iterrows():
    embedding_vector = ast.literal_eval(row[&quot;genre_embeddings&quot;])
    movie_data.append(
        {
            &quot;title&quot;: row[&apos;title&apos;],
            &quot;embeddings&quot;: embedding_vector,
            &quot;genre_labels&quot;: row[&apos;genre_labels&apos;]
        }
    )

# Define LanceDB model
class Movie(LanceModel):
    title: str
    embeddings: Vector(128)  
    genre_labels: str

# Create LanceDB connection
db = lancedb.connect(&quot;./db&quot;)
movie_table = db.create_table(
    &quot;movies&quot;, 
    schema=Movie,
    mode=&quot;Overwrite&quot;)
movie_table.add(movie_data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code might seem overwhelming at first glance, but it’s not as complex as it appears. Essentially, we start by reading the essential data from our CSV file. Then, we establish a connection to LanceDB to set up our table and add our movie data&lt;/p&gt;

&lt;p&gt;Each row in the table corresponds to a single movie, with columns storing data such as title, genres, overview, and embeddings. This columnar format offers a convenient way to store and retrieve information for a variety of tasks related to embeddings.&lt;/p&gt;

&lt;h2 id=&quot;using-genre-spectrum-embeddings-to-get-the-relevant-recommendations&quot;&gt;Using Genre Spectrum Embeddings to get the relevant recommendations.&lt;/h2&gt;

&lt;p&gt;And now, after all the groundwork, we’ve arrived at the final piece of the puzzle. Let’s generate some relevant recommendations using &lt;code&gt;genre_embeddings&lt;/code&gt; and LanceDB VectorDB.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;movie_data_pd = pd.DataFrame(movie_data)
def get_recommendation(title):
    result = (
        movie_table.search(movie_data_pd[movie_data_pd[&quot;title&quot;] == title][&quot;embeddings&quot;].values[0]).metric(&apos;cosine&apos;)
        .limit(5)
        .to_pandas()
    )
    return result

result = get_recommendation(&quot;Toy Story&quot;)
result[[&apos;title&apos;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well let me break down some things for you.&lt;/p&gt;

&lt;p&gt;First, we initialize our LanceDB table containing our relevant data. Then, for a given movie title, we check if we have this title in our dataset. If it exists, we perform a cosine similarity search on all other movies, returning the top 5 most relevant movie titles.&lt;/p&gt;

&lt;p&gt;And just like that, you’ve crafted an impressive movie recommendation system that can swiftly provide you with the best selection of movies. This is made possible by leveraging &lt;code&gt;genre_embeddings&lt;/code&gt; created with the assistance of a neural network and storing them in LanceDB vector database.&lt;/p&gt;

&lt;p&gt;Doing all this will provide you with a list of recommended movies.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Just to clarify, I’ve employed a rudimentary deep learning model architecture to showcase how we can improve our recommendation system. While the movie recommendations may not yield optimal results, the team at Tubi would be the experts to provide you with the exact model architecture they’ve utilized for developing this system.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That being said, Here’s an overview of the entire training code..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from nltk import word_tokenize
from torch.utils.data import DataLoader, TensorDataset
from gensim.models.doc2vec import Doc2Vec, TaggedDocument
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.model_selection import train_test_split
from tqdm import tqdm

import nltk
nltk.download(&apos;punkt&apos;)

# Read data from CSV file
movie_data = pd.read_csv(&apos;movies_metadata.csv&apos;, low_memory=False)
device = torch.device(&apos;cuda&apos; if torch.cuda.is_available() else &apos;cpu&apos;)

def preprocess_data(movie_data_chunk):
    tagged_docs = []
    valid_indices = []
    movie_info = []

    # Wrap your loop with tqdm
    for i, row in tqdm(movie_data_chunk.iterrows(), total=len(movie_data_chunk)):
        try:
            # Constructing movie text
            movies_text = &apos;&apos;
            #movies_text += &quot;Overview: &quot; + row[&apos;overview&apos;] + &apos;\n&apos;
            genres = &apos;, &apos;.join([genre[&apos;name&apos;] for genre in eval(row[&apos;genres&apos;])])
            movies_text += &quot;Genres: &quot; + genres + &apos;\n&apos;
            movies_text += &quot;Title: &quot; + row[&apos;title&apos;] + &apos;\n&apos;
            tagged_docs.append(TaggedDocument(words=word_tokenize(movies_text.lower()), tags=[str(i)]))
            valid_indices.append(i)
            movie_info.append((row[&apos;title&apos;], genres))
        except Exception as e:
            continue

    return tagged_docs, valid_indices, movie_info

def train_doc2vec_model(tagged_data, num_epochs=10):
    # Initialize Doc2Vec model
    doc2vec_model = Doc2Vec(vector_size=100, min_count=2, epochs=num_epochs)
    doc2vec_model.build_vocab(tqdm(tagged_data, desc=&quot;Building Vocabulary&quot;))
    for epoch in range(num_epochs):
        doc2vec_model.train(tqdm(tagged_data, desc=f&quot;Epoch {epoch+1}&quot;), total_examples=doc2vec_model.corpus_count, epochs=doc2vec_model.epochs)
    
    return doc2vec_model

# Preprocess data and extract genres for the first 1000 movies
chunk_size = 1000
tagged_data = []
valid_indices = []
movie_info = []
for chunk_start in range(0, len(movie_data), chunk_size):
    movie_data_chunk = movie_data.iloc[chunk_start:chunk_start+chunk_size]
    chunk_tagged_data, chunk_valid_indices, chunk_movie_info = preprocess_data(movie_data_chunk)
    tagged_data.extend(chunk_tagged_data)
    valid_indices.extend(chunk_valid_indices)
    movie_info.extend(chunk_movie_info)

doc2vec_model = train_doc2vec_model(tagged_data)
doc2vec_model.save(&quot;doc2vec_model&quot;)

# Extract genre labels for the valid indices
genres_list = []
for i in valid_indices:
    row = movie_data.loc[i]
    genres = [genre[&apos;name&apos;] for genre in eval(row[&apos;genres&apos;])]
    genres_list.append(genres)

mlb = MultiLabelBinarizer()
genre_labels = mlb.fit_transform(genres_list)

embeddings = []
for i in valid_indices:
    embeddings.append(doc2vec_model.dv[str(i)])
X_train, X_test, y_train, y_test = train_test_split(embeddings, genre_labels, test_size=0.2, random_state=42)

X_train_np = np.array(X_train, dtype=np.float32)
y_train_np = np.array(y_train, dtype=np.float32)
X_test_np = np.array(X_test, dtype=np.float32)
y_test_np = np.array(y_test, dtype=np.float32)

X_train_tensor = torch.tensor(X_train_np)
y_train_tensor = torch.tensor(y_train_np)
X_test_tensor = torch.tensor(X_test_np)
y_test_tensor = torch.tensor(y_test_np)

class GenreClassifier(nn.Module):
    def __init__(self, input_size, output_size):
        super(GenreClassifier, self).__init__()
        self.fc1 = nn.Linear(input_size, 512)
        self.bn1 = nn.BatchNorm1d(512)
        self.fc2 = nn.Linear(512, 256)
        self.bn2 = nn.BatchNorm1d(256)
        self.fc3 = nn.Linear(256, 128)
        self.bn3 = nn.BatchNorm1d(128)
        self.fc4 = nn.Linear(128, output_size)
        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(p=0.2)  # Adjust the dropout rate as needed

    def forward(self, x):
        x = self.fc1(x)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc2(x)
        x = self.bn2(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc3(x)
        x = self.bn3(x)
        x = self.relu(x)
        x = self.dropout(x)
        x = self.fc4(x)
        return x

# Move model to the selected device
model = GenreClassifier(input_size=100, output_size=len(mlb.classes_)).to(device)

# Define loss function and optimizer
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
epochs = 50
batch_size = 64

train_dataset = TensorDataset(X_train_tensor.to(device), y_train_tensor.to(device))
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)  # Move data to device
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item() * inputs.size(0)
    epoch_loss = running_loss / len(train_loader.dataset)
    print(f&apos;Epoch [{epoch + 1}/{epochs}], Loss: {epoch_loss:.4f}&apos;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the &lt;a href=&quot;https://colab.research.google.com/drive/1B6I5SEXzuuEVaHcy4IwaJlrMy8wJfPSx?usp=sharing&quot;&gt;Colab notebook&lt;/a&gt; for your reference, where you can dive into each component step by step and gain a comprehensive understanding of the process.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Convert any Image dataset to Lance</title>
   <link href="http://localhost:4000/2024/04/09/convert-any-image-dataset-to-lance"/>
   <updated>2024-04-09T00:00:00+05:30</updated>
   <id>http://localhost:4000/2024/04/09/convert-any-image-dataset-to-lance</id>
   <content type="html">&lt;p&gt;In our &lt;a href=&quot;https://vipul-maheshwari.github.io/2024/03/29/effortlessly-loading-and-processing-images-with-lance-a-code-walkthrough&quot;&gt;previous&lt;/a&gt; article, we explored the remarkable capabilities of the Lance format, a modern, columnar data storage solution designed to revolutionize the way we work with large image datasets in machine learning. For the same purpose, I have converted the &lt;code&gt;cinic&lt;/code&gt; and &lt;code&gt;mini-imagenet&lt;/code&gt; datasets to their lance versions. For this write-up, I will use the example of &lt;code&gt;cinic&lt;/code&gt; dataset to explain how to convert any image dataset into the Lance format with a single script and  unlocking the full potential of this powerful technology.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/convert-any-image-dataset-to-lance/meme_reaction.png?raw=true&quot; alt=&quot;lance_converter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;just in case, here are the &lt;a href=&quot;https://www.kaggle.com/datasets/vipulmaheshwarii/cinic-10-lance-dataset&quot;&gt;cinic&lt;/a&gt; and &lt;a href=&quot;https://www.kaggle.com/datasets/vipulmaheshwarii/mini-imagenet-lance-dataset&quot;&gt;mini-imagenet&lt;/a&gt; datasets in lance.&lt;/p&gt;

&lt;h3 id=&quot;processing-images&quot;&gt;Processing Images&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;process_images&lt;/code&gt; function is the heart of our data conversion process. It is responsible for iterating over the image files in the specified dataset, reading the data of each image, and converting it into a PyArrow RecordBatch object on the binary scale. This function also extracts additional metadata, such as the filename, category, and data type (e.g., train, test, or validation), and stores it alongside the image data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def process_images(data_type):
    # Get the current directory path
    images_folder = os.path.join(&quot;cinic&quot;, data_type)

    # Define schema for RecordBatch
    schema = pa.schema([(&apos;image&apos;, pa.binary()), 
                        (&apos;filename&apos;, pa.string()), 
                        (&apos;category&apos;, pa.string()), 
                        (&apos;data_type&apos;, pa.string())])

    # Iterate over the categories within each data type
    for category in os.listdir(images_folder):
        category_folder = os.path.join(images_folder, category)
        
        # Iterate over the images within each category
        for filename in tqdm(os.listdir(category_folder), desc=f&quot;Processing {data_type} - {category}&quot;):
            # Construct the full path to the image
            image_path = os.path.join(category_folder, filename)

            # Read and convert the image to a binary format
            with open(image_path, &apos;rb&apos;) as f:
                binary_data = f.read()

            image_array = pa.array([binary_data], type=pa.binary())
            filename_array = pa.array([filename], type=pa.string())
            category_array = pa.array([category], type=pa.string())
            data_type_array = pa.array([data_type], type=pa.string())

            # Yield RecordBatch for each image
            yield pa.RecordBatch.from_arrays(
                [image_array, filename_array, category_array, data_type_array],
                schema=schema
            )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By leveraging the PyArrow library, the &lt;code&gt;process_images&lt;/code&gt; function ensures that the image data is represented in a format that is compatible with the Lance format. The use of &lt;code&gt;RecordBatch&lt;/code&gt; objects allows for efficient data structuring and enables seamless integration with the subsequent steps of the conversion process.&lt;/p&gt;

&lt;p&gt;One of the key features of this function is its ability to handle datasets with a hierarchical structure. It iterates over the categories within each data type, ensuring that the metadata associated with each image is accurately captured and preserved. This attention to detail is crucial, as it allows us to maintain the rich contextual information of us image dataset, which can be invaluable for tasks like classification, object detection, or semantic segmentation.&lt;/p&gt;

&lt;h3 id=&quot;writing-to-lance&quot;&gt;Writing to Lance&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;write_to_lance&lt;/code&gt; function takes the data generated by the &lt;code&gt;process_images&lt;/code&gt; function and writes it to Lance datasets, one for each data type (e.g., train, test, validation). This step is where the true power of the Lance format is unleashed.&lt;/p&gt;

&lt;p&gt;The function first creates a PyArrow schema that defines the structure of the data to be stored in the Lance format. This schema includes the image data, as well as the associated metadata (filename, category, and data type). By specifying the schema upfront, the script ensures that the data is stored in a consistent and organized manner, making it easier to retrieve and work with in the future.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def write_to_lance():
    # Create an empty RecordBatchIterator
    schema = pa.schema([
        pa.field(&quot;image&quot;, pa.binary()),
        pa.field(&quot;filename&quot;, pa.string()),
        pa.field(&quot;category&quot;, pa.string()),
        pa.field(&quot;data_type&quot;, pa.string())
    ])

    # Specify the path where you want to save the Lance files
    images_folder = &quot;cinic&quot;
    
    for data_type in [&apos;train&apos;, &apos;test&apos;, &apos;val&apos;]:
        lance_file_path = os.path.join(images_folder, f&quot;cinic_{data_type}.lance&quot;)
        
        reader = pa.RecordBatchReader.from_batches(schema, process_images(data_type))
        lance.write_dataset(
            reader,
            lance_file_path,
            schema,
        )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, the function iterates through the different data types, creating a Lance dataset file for each one. The &lt;code&gt;lance.write_dataset&lt;/code&gt; function is then used to write the &lt;code&gt;RecordBatchReader&lt;/code&gt;, generated from the &lt;code&gt;process_images&lt;/code&gt; function, to the respective Lance dataset files.&lt;/p&gt;

&lt;p&gt;The benefits of this approach are numerous. By storing the data in the Lance format, you can take advantage of its columnar storage and compression techniques, resulting in significantly reduced storage requirements. Additionally, the optimized data layout and indexing capabilities of Lance enable lightning-fast data loading times, improving the overall performance and responsiveness of your machine learning pipelines.&lt;/p&gt;

&lt;h3 id=&quot;loading-into-pandas&quot;&gt;Loading into Pandas&lt;/h3&gt;

&lt;p&gt;The final step in the process is to load the data from the Lance datasets into Pandas DataFrames, making the image data easily accessible for further processing and analysis in your machine learning workflows.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;loading_into_pandas&lt;/code&gt; function demonstrates this process. It first locates the Lance dataset files, created in the previous step, and creates a Lance dataset object for each data type. The function then iterates over the batches of data, converting them into Pandas DataFrames and concatenating them into a single DataFrame for each data type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
def loading_into_pandas():
    # Load Lance files from the same folder
    current_dir = os.getcwd()
    images_folder = os.path.join(current_dir, &quot;cinic&quot;)
    
    data_frames = {}  # Dictionary to store DataFrames for each data type
    
    for data_type in [&apos;test&apos;, &apos;train&apos;, &apos;val&apos;]:
        uri = os.path.join(images_folder, f&quot;cinic_{data_type}.lance&quot;)

        ds = lance.dataset(uri)

        # Accumulate data from batches into a list
        data = []
        for batch in tqdm(ds.to_batches(columns=[&quot;image&quot;, &quot;filename&quot;, &quot;category&quot;, &quot;data_type&quot;], batch_size=10), desc=f&quot;Loading {data_type} batches&quot;):
            tbl = batch.to_pandas()
            data.append(tbl)

        # Concatenate all DataFrames into a single DataFrame
        df = pd.concat(data, ignore_index=True)
        
        # Store the DataFrame in the dictionary
        data_frames[data_type] = df
        
        print(f&quot;Pandas DataFrame for {data_type} is ready&quot;)
        print(&quot;Total Rows: &quot;, df.shape[0])
    
    return data_frames
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach offers several advantages. By loading the data in batches, the function can efficiently handle large-scale image datasets without running into memory constraints. Additionally, the use of Pandas DataFrames provides a familiar and intuitive interface for working with the data, allowing you to leverage the rich ecosystem of Pandas-compatible libraries and tools for data manipulation, visualization, and analysis.&lt;/p&gt;

&lt;p&gt;Moreover, the function stores the DataFrames in a list, indexed by the data type. This structure enables us to easily access the specific subsets of your dataset (e.g., train, test, validation) as needed, further streamlining your machine learning workflows. I mean it’s too smooth guys.&lt;/p&gt;

&lt;h3 id=&quot;putting-it-all-together&quot;&gt;Putting It All Together&lt;/h3&gt;
&lt;p&gt;By running the provided script, you can convert your image datasets, whether they are industry-standard benchmarks or your own custom collections, into the powerful Lance format. This transformation unlocks a new level of efficiency and performance, empowering you to supercharge your machine learning projects.  I have used the same script for the &lt;code&gt;mini-imagenet&lt;/code&gt; too, make sure your data directory looks like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/convert-any-image-dataset-to-lance/cinic_image.png?raw=true&quot; alt=&quot;data_folders&quot; /&gt;&lt;/p&gt;

&lt;p&gt;here is the complete script for your reference..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import os
import pandas as pd
import pyarrow as pa
import lance
import time
from tqdm import tqdm

def process_images(data_type):
    # Get the current directory path
    images_folder = os.path.join(&quot;cinic&quot;, data_type)

    # Define schema for RecordBatch
    schema = pa.schema([(&apos;image&apos;, pa.binary()), 
                        (&apos;filename&apos;, pa.string()), 
                        (&apos;category&apos;, pa.string()), 
                        (&apos;data_type&apos;, pa.string())])

    # Iterate over the categories within each data type
    for category in os.listdir(images_folder):
        category_folder = os.path.join(images_folder, category)
        
        # Iterate over the images within each category
        for filename in tqdm(os.listdir(category_folder), desc=f&quot;Processing {data_type} - {category}&quot;):
            # Construct the full path to the image
            image_path = os.path.join(category_folder, filename)

            # Read and convert the image to a binary format
            with open(image_path, &apos;rb&apos;) as f:
                binary_data = f.read()

            image_array = pa.array([binary_data], type=pa.binary())
            filename_array = pa.array([filename], type=pa.string())
            category_array = pa.array([category], type=pa.string())
            data_type_array = pa.array([data_type], type=pa.string())

            # Yield RecordBatch for each image
            yield pa.RecordBatch.from_arrays(
                [image_array, filename_array, category_array, data_type_array],
                schema=schema
            )

# Function to write PyArrow Table to Lance dataset
def write_to_lance():
    # Create an empty RecordBatchIterator
    schema = pa.schema([
        pa.field(&quot;image&quot;, pa.binary()),
        pa.field(&quot;filename&quot;, pa.string()),
        pa.field(&quot;category&quot;, pa.string()),
        pa.field(&quot;data_type&quot;, pa.string())
    ])

    # Specify the path where you want to save the Lance files
    images_folder = &quot;cinic&quot;
    
    for data_type in [&apos;train&apos;, &apos;test&apos;, &apos;val&apos;]:
        lance_file_path = os.path.join(images_folder, f&quot;cinic_{data_type}.lance&quot;)
        
        reader = pa.RecordBatchReader.from_batches(schema, process_images(data_type))
        lance.write_dataset(
            reader,
            lance_file_path,
            schema,
        )

def loading_into_pandas():
    # Load Lance files from the same folder
    current_dir = os.getcwd()
    print(current_dir)
    images_folder = os.path.join(current_dir, &quot;cinic&quot;)
    
    data_frames = {}  # Dictionary to store DataFrames for each data type
    
    for data_type in [&apos;test&apos;, &apos;train&apos;, &apos;val&apos;]:
        uri = os.path.join(images_folder, f&quot;cinic_{data_type}.lance&quot;)

        ds = lance.dataset(uri)

        # Accumulate data from batches into a list
        data = []
        for batch in tqdm(ds.to_batches(columns=[&quot;image&quot;, &quot;filename&quot;, &quot;category&quot;, &quot;data_type&quot;], batch_size=10), desc=f&quot;Loading {data_type} batches&quot;):
            tbl = batch.to_pandas()
            data.append(tbl)

        # Concatenate all DataFrames into a single DataFrame
        df = pd.concat(data, ignore_index=True)
        
        # Store the DataFrame in the dictionary
        data_frames[data_type] = df
        
        print(f&quot;Pandas DataFrame for {data_type} is ready&quot;)
        print(&quot;Total Rows: &quot;, df.shape[0])
    
    return data_frames


if __name__ == &quot;__main__&quot;:
    start = time.time()
    write_to_lance()
    data_frames = loading_into_pandas()
    end = time.time()
    print(f&quot;Time(sec): {end - start}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take the different splits of the train, test and validation through different dataframes and utilize the information for your next image classifcation task&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;train = data_frames[&apos;train&apos;]
test = data_frames[&apos;test&apos;]
val = data_frames[&apos;val&apos;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and this is how the training dataframe looks like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;train.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;image	filename	category	data_type
	image	filename	category	data_type
0	b&apos;\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\...	n02130308_1836.png	cat	train
1	b&apos;\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\...	cifar10-train-21103.png	cat	train
2	b&apos;\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\...	cifar10-train-44957.png	cat	train
3	b&apos;\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\...	n02129604_14997.png	cat	train
4	b&apos;\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\...	n02123045_1463.png	cat	train
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The benefits of this approach are numerous:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Storage Efficiency: The columnar storage and compression techniques employed by Lance result in significantly reduced storage requirements, making it an ideal choice for handling large-scale image datasets.&lt;/li&gt;
  &lt;li&gt;Fast Data Loading: The optimized data layout and indexing capabilities of Lance enable lightning-fast data loading times, improving the overall performance and responsiveness of your machine learning pipelines.&lt;/li&gt;
  &lt;li&gt;Random Access: The ability to selectively load specific data subsets from the Lance dataset allows for efficient data augmentation techniques and custom data loading strategies tailored to your unique requirements.&lt;/li&gt;
  &lt;li&gt;Unified Data Format: Lance can store diverse data types, such as images, text, and numerical data, in a single, streamlined format. This flexibility is invaluable in machine learning, where different modalities of data often need to be processed together.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By adopting the Lance format, we can literally elevate our machine learning workflow to new heights, unlocking unprecedented levels of efficiency, performance, and flexibility. Take the first step by running the provided script and converting your image datasets to the Lance format – the future of machine learning data management is awaiting for you, who knows if you find your second love with lance format.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Effortlessly Loading and Processing Images with Lance</title>
   <link href="http://localhost:4000/2024/03/29/effortlessly-loading-and-processing-images-with-lance-a-code-walkthrough"/>
   <updated>2024-03-29T00:00:00+05:30</updated>
   <id>http://localhost:4000/2024/03/29/effortlessly-loading-and-processing-images-with-lance-a-code-walkthrough</id>
   <content type="html">&lt;p&gt;Working with large image datasets in machine learning can be challenging, often requiring significant computational resources and efficient data-handling techniques. While widely used for image storage, traditional file formats like JPEG or PNG are not optimized for efficient data loading and processing in Machine learning workflows. This is where the Lance format shines, offering a modern, columnar data storage solution designed specifically for machine learning applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/loading_and_processing_image_with_lance/image.png?raw=true&quot; alt=&quot;meme_for_ml_workloads&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The Lance format stores data in a compressed columnar format, enabling efficient storage, fast data loading, and fast random access to data subsets. Additionally, the Lance format is maintained on disk, which provides a couple of advantages: It will persist through a system failure and doesn’t rely on keeping everything in memory, which can run out. This also lends itself to enhanced data privacy and security, as the data doesn’t need to be transferred over a network.&lt;/p&gt;

&lt;p&gt;One of the other key advantages of the Lance format is its ability to store diverse data types, such as images, text, and numerical data, in a unified format. Imagine having a data lake where each kind of data can be stored seamlessly without separating underlying data types. This flexibility is particularly valuable in machine learning pipelines, where different data types often need to be processed together. This unparalleled flexibility is a game-changer in machine learning pipelines, where different modalities of data often need to be processed together for tasks like multimodal learning, audio-visual analysis, or natural language processing with visual inputs.&lt;/p&gt;

&lt;p&gt;With Lance, you can effortlessly consider all kinds of data, from images to videos and audio files to text data and numerical values, all within the same columnar storage format. This means you can have a single, streamlined data pipeline that can handle any combination of data types without the need for complex data transformations or conversions. Lance easily handles it without worrying about compatibility issues or dealing with separate storage formats for different data types. And the best part? You can store and retrieve all these diverse data types within the same column.&lt;/p&gt;

&lt;p&gt;In contrast, while efficient for tabular data, traditional formats like Parquet may need to handle diverse data types better. By converting all data into a single, unified format using Lance, you can retrieve and process any type of data without dealing with multiple formats or complex data structures.
In this article, I’ll walk through a Python code example that demonstrates how to convert a dataset of GTA5 images into the Lance format and subsequently load them into a Pandas DataFrame for further processing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import os
import pandas as pd
import pyarrow as pa
import lance
import time
from tqdm import tqdm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start by importing the necessary libraries, including os for directory handling, pandas for data manipulation, pyarrow for working with Arrow data formats, lance for interacting with the Lance format, and tqdm for displaying progress bars.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def process_images():
    current_dir = os.getcwd()
    images_folder = os.path.join(current_dir, &quot;./image&quot;)

    # Define schema for RecordBatch
    schema = pa.schema([(&apos;image&apos;, pa.binary())])

    image_files = [filename for filename in os.listdir(images_folder)
                if filename.endswith((&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;))]

    # Iterate over all images in the folder with tqdm
    for filename in tqdm(image_files, desc=&quot;Processing Images&quot;):
        # Construct the full path to the image
        image_path = os.path.join(images_folder, filename)

        # Read and convert the image to a binary format
        with open(image_path, &apos;rb&apos;) as f:
            binary_data = f.read()

        image_array = pa.array([binary_data], type=pa.binary())

        # Yield RecordBatch for each image
        yield pa.RecordBatch.from_arrays([image_array], schema=schema)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The process_images function is responsible for iterating over all image files in a specified directory and converting them into PyArrow RecordBatch objects. It first defines the schema for the RecordBatch, specifying that each batch will contain a single binary column named ‘image’.&lt;/p&gt;

&lt;p&gt;It then iterates over all image files in the directory, reads each image’s binary data, and yields a RecordBatch containing that image’s binary data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def write_to_lance():
    schema = pa.schema([
        pa.field(&quot;image&quot;, pa.binary())
    ])

    reader = pa.RecordBatchReader.from_batches(schema, process_images())
    lance.write_dataset(
        reader,
        &quot;image_dataset.lance&quot;,
        schema,
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The write_to_lance function creates a RecordBatchReader from the process_images generator and writes the resulting data to a Lance dataset named “image_dataset.lance”. This step converts the image data into the efficient, columnar Lance format, optimizing it for fast data loading and random access.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def loading_into_pandas():
    uri = &quot;image_dataset.lance&quot;
    ds = lance.dataset(uri)

    # Accumulate data from batches into a list
    data = []
    for batch in ds.to_batches(columns=[&quot;image&quot;], batch_size=10):
        tbl = batch.to_pandas()
        data.append(tbl)

    # Concatenate all DataFrames into a single DataFrame
    df = pd.concat(data, ignore_index=True)
    print(&quot;Pandas DataFrame is ready&quot;)
    print(&quot;Total Rows: &quot;, df.shape[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The loading_into_pandas function demonstrates how to load the image data from the Lance dataset into a Pandas DataFrame. It first creates a Lance dataset object from the “image_dataset.lance” file. Then, it iterates over batches of data, converting each batch into a Pandas DataFrame and appending it to a list. Finally, it concatenates all the DataFrames in the list into a single DataFrame, making the image data accessible for further processing or analysis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;if __name__ == &quot;__main__&quot;:
    start = time.time()
    write_to_lance()
    loading_into_pandas()
    end = time.time()
    print(f&quot;Time(sec): {end - start}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The central part of the script calls the write_to_lance and loading_into_pandas functions, measuring the total execution time for the entire process.
By leveraging the Lance format, this code demonstrates how to efficiently store and load large image datasets for machine learning applications. The columnar storage and compression techniques Lance uses result in reduced storage requirements and faster data loading times, making it an ideal choice for working with large-scale image data.&lt;/p&gt;

&lt;p&gt;Moreover, the random access capabilities of Lance allow for selective loading of specific data subsets, enabling efficient data augmentation techniques and custom data loading strategies tailored to your machine learning workflow.&lt;/p&gt;

&lt;p&gt;TLDR: Lance format provides a powerful and efficient solution for handling multimodal data in machine learning pipelines, streamlining data storage, loading, and processing tasks. By adopting Lance, we can improve our machine learning projects’ overall performance and resource efficiency while also benefiting from the ability to store diverse data types in a unified format and maintain data locality and privacy. Here is the whole script for your reference.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import os
import pandas as pd
import pyarrow as pa
import lance
import time
from tqdm import tqdm

def process_images():
    current_dir = os.getcwd()
    images_folder = os.path.join(current_dir, &quot;./image&quot;)

    # Define schema for RecordBatch
    schema = pa.schema([(&apos;image&apos;, pa.binary())])

    image_files = [filename for filename in os.listdir(images_folder)
                if filename.endswith((&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;))]

    # Iterate over all images in the folder with tqdm
    for filename in tqdm(image_files, desc=&quot;Processing Images&quot;):
        # Construct the full path to the image
        image_path = os.path.join(images_folder, filename)

        # Read and convert the image to a binary format
        with open(image_path, &apos;rb&apos;) as f:
            binary_data = f.read()

        image_array = pa.array([binary_data], type=pa.binary())

        # Yield RecordBatch for each image
        yield pa.RecordBatch.from_arrays([image_array], schema=schema)

def write_to_lance():
    
    schema = pa.schema([
        pa.field(&quot;image&quot;, pa.binary())
    ])

    reader = pa.RecordBatchReader.from_batches(schema, process_images())
    lance.write_dataset(
        reader,
        &quot;image_dataset.lance&quot;,
        schema,
    )

def loading_into_pandas():

    uri = &quot;image_dataset.lance&quot;
    ds = lance.dataset(uri)

    # Accumulate data from batches into a list
    data = []
    for batch in ds.to_batches(columns=[&quot;image&quot;], batch_size=10):
        tbl = batch.to_pandas()
        data.append(tbl)

    # Concatenate all DataFrames into a single DataFrame
    df = pd.concat(data, ignore_index=True)
    print(&quot;Pandas DataFrame is ready&quot;)
    print(&quot;Total Rows: &quot;, df.shape[0])


if __name__ == &quot;__main__&quot;:
    start = time.time()
    write_to_lance()
    loading_into_pandas()
    end = time.time()
    print(f&quot;Time(sec): {end - start}&quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Imagine using Lance-formatted image data to make machine learning and deep learning projects faster. Something big is coming up, stay tuned.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Embedded Databases</title>
   <link href="http://localhost:4000/2024/03/15/embedded-databases"/>
   <updated>2024-03-15T00:00:00+05:30</updated>
   <id>http://localhost:4000/2024/03/15/embedded-databases</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/embedded_databases/production_fucked.png?raw=true&quot; alt=&quot;production_fucked&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In today’s world, when everyone’s curious about trying out generative AI tools and how they work, you’ve probably heard about embedded databases. Most of us tend to think about client-server based setups when databases come to mind. And honestly, that’s somewhat accurate.&lt;/p&gt;

&lt;p&gt;However, client-server architectures aren’t really built to handle heavy analytical and ML workloads. Essentially, the processing tasks fall into two main categories: OLTP (online transactional processing) and OLAP (online analytical processing). So, when you’re changing your Instagram profile picture or uploading a photo on Facebook, you’re essentially involved in OLTP tasks, which focus on quick and easy processing. On the flip side, when we deal with OLAP, it’s all about handling complex computations such as retrieving queries from extensive datasets, combining tables, and aggregating data for big data purposes. Now, we need something that can handle our large ML workloads effectively and perform optimally across datasets ranging from small to large scales.&lt;/p&gt;

&lt;h3 id=&quot;columnar-oriented-datastores&quot;&gt;Columnar Oriented Datastores&lt;/h3&gt;

&lt;p&gt;Hard drives store data in terms of blocks, so whenever an operation is performed, the entire block containing the data is loaded into memory for reading by the OS. Now, Row-oriented databases aim to store whole rows of the database in the same block, whereas columnar databases store column entries in the same block.&lt;/p&gt;

&lt;p&gt;This implies that when you need to perform column-oriented operations like updating columns, aggregations, or selecting a column entry, column-oriented databases outperform row-oriented ones in terms of speed. However, if you need to add a new data point entry with multiple columns, then row-oriented databases perform better.&lt;/p&gt;

&lt;p&gt;Now, the point is, there’s something called Apache Arrow, which is a language-agnostic columnar memory format for flat and hierarchical data, organized for efficient analytic operations on modern hardware like CPUs and GPUs.&lt;/p&gt;

&lt;p&gt;This is too technical. Let me break it down for you. Machine learning is all about feeding huge amounts of data into complex mathematical models to find patterns and make predictions, right? Now, Apache Arrow turbocharges this process by providing a standardized way to store and work with data that’s &lt;a href=&quot;https://developer.nvidia.com/blog/accelerating-apache-spark-3-0-with-gpus-and-rapids/&quot;&gt;optimized&lt;/a&gt; for modern hardware like powerful GPUs. So Instead of dealing with clunky row-based formats, Arrow’s columnar layout lets you focus on the specific data features you need, drastically cutting down processing time. And since Arrow keeps data in memory, AKA RAM, rather than on sluggish disk storage like hard drives or SSDs, your models can crunch through datasets at blistering speeds. The end result? You can iterate faster, train better models, and stay ahead of the competition.&lt;/p&gt;

&lt;p&gt;Still confused, right? I was too. Well, let’s take an example. If you’re building a model to predict housing prices based on factors like square footage, number of bedrooms, location, etc., Arrow’s columnar format would allow you to easily isolate and work with just the columns containing those specific features, ignoring any other irrelevant data columns. This focused, selective data access is more efficient than dealing with row-based formats where you’d have to sort through all the data indiscriminately.&lt;/p&gt;

&lt;p&gt;Now that’s where the power of Arrow based columnar databases comes into play.&lt;/p&gt;

&lt;h3 id=&quot;lance-data-format&quot;&gt;Lance Data Format&lt;/h3&gt;

&lt;p&gt;Building on the advantages of Apache Arrow’s columnar, in-memory approach for machine learning, there’s another game-changing data format that takes things to a whole new level – the Lance Data Format.&lt;/p&gt;

&lt;p&gt;Designed from the ground up with modern ML workflows in mind, Lance is an absolute speed demon when it comes to querying and prepping data for training models. But it’s not just about raw speed – Lance has some seriously impressive versatility under the hood.&lt;/p&gt;

&lt;p&gt;Unlike formats limited to tabular data, Lance can handle all kinds of data types like images, videos, 3D point clouds, audio, and more. It’s like a Swiss Army knife of data formats for ML. Btw, Don’t just take my word for it because I love LanceDB, instead – &lt;a href=&quot;https://blog.lancedb.com/announcing-lancedb-5cb0deaa46ee-2/&quot;&gt;benchmarks&lt;/a&gt; have shown that Lance can provide random data access involving read and write operation a mind-boggling approximately 1000 times faster than Parquet, another popular columnar format. This blistering speed comes from unique storage memory layout used by Lance.&lt;/p&gt;

&lt;p&gt;The other important thing LanceDB provides is the usage of Zero-copy versioning, essentially it means that when you create a new version of your data, LanceDB doesn’t have to make an entire copy – it just stores the changes efficiently. This saves a ton of time and storage space compared to traditional versioning methods. And optimized vector operations allow Lance to process data in bulk, taking full advantage of modern hardware like GPUs and vectorized CPUs. It’s all part of Lance’s cloud-native design.&lt;/p&gt;

&lt;h3 id=&quot;in-process&quot;&gt;In-process&lt;/h3&gt;

&lt;p&gt;Before understanding what Embedded Systems really do, First, we need to understand what a database management system (DBMS) is in Layman. Now in simple terms a DBMS is a software system that allows you to create, manage, and interact with databases (obviously duhh). I mean It provides a way to store, retrieve, and manipulate data in an organized and more efficient manner.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/embedded_databases/in_process_setting.png?raw=true&quot; alt=&quot;inprocess_setting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, an embedded database is a type of DBMS that is tightly integrated with the application layer. This means that the database that you are working with is not a separate process or service running on its own; instead, it runs within the same process as the application itself.&lt;/p&gt;

&lt;p&gt;This tight integration makes it easier for the application to interact with the database, as there’s no need for inter-process communication or network communication unlike traditional client-server database systems where the database is a  separate process or a service&lt;/p&gt;

&lt;p&gt;This type of thing is called “in-process”. Remember this for the rest of your life. It might be the most important thing to remember when judging the other embedded databases out there.&lt;/p&gt;

&lt;p&gt;In simple terms, the application can directly access and manipulate the database without going through additional layers or protocols. CUTTING THE BS.&lt;/p&gt;

&lt;h3 id=&quot;on-disk-storage&quot;&gt;&lt;strong&gt;On-disk storage&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Remember I said earlier that Embedded systems have this ability to store the data in-memory and work at blistering speeds. While embedded databases can store data in memory, they also have this capability to store larger datasets on disk. This allows them to scale to large amounts of data (terabytes or billion dataset points, think of embeddings of billion tokens) while still providing relatively low query latencies and response times. So it’s like the best of the both worlds.&lt;/p&gt;

&lt;h3 id=&quot;serverless&quot;&gt;Serverless&lt;/h3&gt;

&lt;p&gt;Ok new term! Sometimes the terms “Embedded” and “Serverless” are sometimes used interchangeably in the database community, but they actually refer to different concepts. “Embedded” refers to the database being tightly integrated with the application as we seen earlier in case of Embedded databases while Serverless refers to the separation of storage and compute resources, and it’s often used in the context of microservices architectures.&lt;/p&gt;

&lt;p&gt;To make it more concise, think of the serverless database as it’s composed of two different containers, the storage layer (where the data is stored) and the compute layer (where the data is processed). Now this separation allows the compute resources to be dynamically allocated and scaled up or down based on the workload.&lt;/p&gt;

&lt;p&gt;And btw, when we are talking about the Serverless model, it is often associated with the cloud based services, where you don’t have to manage the underlying infra..&lt;/p&gt;

&lt;h3 id=&quot;scalability&quot;&gt;Scalability&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/embedded_databases/lancedb_scaled.png?raw=true&quot; alt=&quot;lancedb_scaled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ok so you decided to work on the simple RAG system and wanted to test it out or just maybe play with it and came up with the various vector databases, you did your experiment,  you are happy and done. Now when you got serious and came up with something and wanted to scale your RAG system for let’s say 1 billion embeddings, you open up your earlier setup, ingested more data, created more embeddings and when the time came, your traditional embedding database gave you nightmares in terms of the latency as well as stability.&lt;/p&gt;

&lt;p&gt;Now, Think of an open-source embedding database designed to seamlessly handle a variety of setups and effortlessly scales up to billions of vectors locally., scales up to billions of embeddings, fetch the relevant embeddings with amazing searching capabilities and data never leaves your local machine, feels too good to be true right?! Well there is LanceDB again. I mean from the moment you dirty your hands for your next RAG system all upto the time you put something as big as production, LanceDB scales amazingly well…&lt;/p&gt;

&lt;h3 id=&quot;multimodality&quot;&gt;Multimodality&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/embedded_databases/multimodality_in_lancedb.png?raw=true&quot; alt=&quot;multimodality&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The current embedded databases should not only support textual data but also be compatible with various file formats. It’s no longer just about text ingestion. Some time ago, I developed a GTA-5 multimodal RAG application that displays the GTA5 landscape upon entering a query. I highly recommend giving it a &lt;a href=&quot;https://vipul-maheshwari.github.io/2024/03/03/multimodal-rag-application&quot;&gt;read&lt;/a&gt; to understand why the Multimodal RAG system is the new hotshot and why companies are eager to integrate it into their core. Honestly, I haven’t come across any embedded vector database other than LanceDB that can effortlessly ingest any kind of file format.&lt;/p&gt;

&lt;p&gt;By the way, multimodality does make sense because LanceDB is built on top of the Lance format. As mentioned earlier, it supports diverse data types, including images, audio, and text, making it incredibly flexible for applications with various data formats.&lt;/p&gt;

&lt;h3 id=&quot;searching-and-integrations&quot;&gt;Searching and Integrations&lt;/h3&gt;

&lt;p&gt;Ok, so we stored the Embeddings, we scaled our RAG too, now for a given query, we want to find the relevant embeddings, and that’s where LanceDB shines. Now Searching in LanceDB is as easy as it could be, you can just query your data in a number of ways - via SQL, full-text search , and vector search. As it supports the Hybrid search too which is one of the biggest favorable for the amazing search capabilities in LanceDB.&lt;/p&gt;

&lt;p&gt;But it’s not just about searching guys, it integrates well enough with native Python, JavaScript/TypeScript, Pandas, Pydantic, that means you can easily integrate it with your favorite programming languages, in addition to that, it has direct integrations with cloud storage providers like AWS S3 and Azure Blob Storage. This means that we can directly query data stored on the cloud, without any added ETL steps.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/embedded_databases/grandma_knows.png?raw=true&quot; alt=&quot;grandma_knows&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Woah, I do love LanceDB&lt;/p&gt;
&lt;h3 id=&quot;more-or-less-we-looked-at-these-things-right-&quot;&gt;More or less, we looked at these things right :&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Columnar Oriented Databases&lt;/li&gt;
  &lt;li&gt;Lance Format&lt;/li&gt;
  &lt;li&gt;In-process&lt;/li&gt;
  &lt;li&gt;On-disk storage&lt;/li&gt;
  &lt;li&gt;Serverless&lt;/li&gt;
  &lt;li&gt;Embedded systems.&lt;/li&gt;
  &lt;li&gt;Scalability&lt;/li&gt;
  &lt;li&gt;Multimodality&lt;/li&gt;
  &lt;li&gt;Searching and Integrations&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/embedded_databases/gen_ai_applications.png?raw=true&quot; alt=&quot;gen_ai_application&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Well all of them are bundled together with no cost upfront, ready to serve in one installation click and voila baby, you have your new best friend, maybe more than that, who knows? So what are you waiting for? Here is the &lt;a href=&quot;https://lancedb.com/&quot;&gt;reference&lt;/a&gt;, see you soon.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Multimodal RAG applications</title>
   <link href="http://localhost:4000/2024/03/03/multimodal-rag-application"/>
   <updated>2024-03-03T00:00:00+05:30</updated>
   <id>http://localhost:4000/2024/03/03/multimodal-rag-application</id>
   <content type="html">&lt;p&gt;&lt;em&gt;Artificial Intelligence (AI) has been actively working with text for quite some time, but the world isn’t solely centered around words. If you take a moment to look around, you’ll find a mix of text, images, videos, audios, and their combinations.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/Renevant%20Cheetah-66.jpg?raw=true&quot; alt=&quot;boomer_ai&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Today we are going to work on Multimodality which is basically a concept that essentially empowers AI models with the capacity to perceive, listen, and comprehend data in diverse formats together with the text. Pretty much like how we do!&lt;/p&gt;

&lt;p&gt;In an ideal situation, we should be able to mix different types of data together and show them to a generative AI model at the same time and iterate on it. It could be as simple as telling the AI model, “Hey, a few days ago, I sent you a picture of a brown, short dog. Can you find that picture for me?” and the model should then give us the details of that picture. Basically, we want the AI to understand things more like how we humans do,  becoming really good at handling and responding to all kinds of information.&lt;/p&gt;

&lt;p&gt;But the challenge here is to make a computer understand one data format with its related reference, and that could be a mix of text, audio, thermal imagery, and videos. Now to make this happen, we use something called Embeddings. It’s really a numeric vector which contains a bunch of numbers written together that might not mean much to us but are understood by machines very well.&lt;/p&gt;

&lt;h3 id=&quot;cat-is-equal-to-cat&quot;&gt;Cat is equal to Cat&lt;/h3&gt;

&lt;p&gt;Let’s think of the text components for now, so we are currently aiming that our model should learn that words like “Dog” and “Cat” are closely linked to the word “Pet.” Now this understanding is easily achievable by using an embedding model which will convert these text words into their respective embeddings first and then the model is trained to follow a straightforward logic: if words are related, they are close together in the vector space, if not, they would be separated by the adequate distance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/embeddings.png?raw=true&quot; alt=&quot;embeddings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But to help a model recognize that an image of a “Cat” and the word “Cat” are similar, we rely on Multimodal Embeddings. To simplify things a bit, imagine there is a magic box which is capable of handling various inputs – images, audios, text, and more.&lt;/p&gt;

&lt;p&gt;Now, when we feed the box with an image of a “Cat” with the text “Cat,” it performs its magic and produces two numeric vectors. When these two vectors were given to a machine, it made machines think, “Hmm, based on these numeric values, it seems like both are connected to “Cat”. So that’s exactly what we were aiming for! Our goal was to help machines to recognize the close connection between an image of a “Cat” and the text “Cat”. However, to validate this concept, when we plot those two numeric vectors in a vector space, it turns out they are very close to each other. This outcome exactly mirrors what we observed earlier with the proximity of the two text words “Cat” and “Dog” in the vector space.&lt;/p&gt;

&lt;h2 id=&quot;ladies-and-gentlemen-thats-the-essence-of-multimodality-&quot;&gt;Ladies and gentlemen, that’s the essence of Multimodality. 👏&lt;/h2&gt;

&lt;p&gt;So we made our model to comprehend the association between “Cat” images and the word “Cat.” Well this is it, I mean if you are able to do this, you would have ingested the audio, images, videos as well as the word “Cat” and the model will understand how the cat is being portrayed across all kinds of file format..&lt;/p&gt;

&lt;h3 id=&quot;rag-is-here&quot;&gt;RAG is here..&lt;/h3&gt;

&lt;p&gt;Well if you don’t know what RAG means, I would highly advise you to read this article &lt;a href=&quot;https://vipul-maheshwari.github.io/2024/02/14/rag-application-with-langchain&quot;&gt;here&lt;/a&gt; which I wrote some days back and loved by tons of people, not exaggerating it but yeah, it’s good to get the balls rolling..&lt;/p&gt;

&lt;p&gt;So there are impressive models like DALLE-2 that provide text-to-image functionality. Essentially, you input text, and the model generates relevant images for you. But can we create a system similar to Multimodal RAG, where the model produces output images based on our own data? Alright, so the goal for today is to create an AI model that when asked something like, “How many girls were there in my party?” 💀 not only provides textual information but also includes a relevant image related to it. Think of it as an extension of a simple RAG system, but now incorporating images.&lt;/p&gt;

&lt;p&gt;Before we dive in, remember that Multimodality isn’t limited to just text-to-image or image-to-text as it encompasses the freedom to input and output any type of data. However, for now, let’s concentrate on the interaction from image to text exclusively.&lt;/p&gt;

&lt;h3 id=&quot;contrastive-learning&quot;&gt;Contrastive learning&lt;/h3&gt;

&lt;p&gt;Now the question is, What exactly was that box doing? The magic it performs is known as Contrastive Learning. While the term might sound complex, it’s not that tricky. To simplify, consider a dataset with images, along with a caption describing what the image represents.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/clipmodel.png?raw=true&quot; alt=&quot;clipmodel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Alright, now what happens is: we give our text-image model with these Positive and Negative samples, where each sample consists of an image and a descriptive text. Positive samples are those where the image and text are correctly aligned – for instance, a picture of a cat matched with the text “this is an image of a cat.” Conversely, negative samples involve a mismatch, like presenting an image of a dog alongside the text “this is an image of a cat.”&lt;/p&gt;

&lt;p&gt;Now we train our text-image model to recognize that positive samples offer accurate interpretations, while negative samples are misleading and should be disregarded during training. In formal terms this technique is called &lt;a href=&quot;https://openai.com/research/clip&quot;&gt;CLIP&lt;/a&gt; (Contrastive Language-Image Pre-training) introduced by OpenAI where authors trained an image-text model on something around 400 million image caption pairs taken from the internet and everytime model makes a mistake, the contrastive loss function increases and penalize it to make sure the model trains well. The same kind of principles are applied to the other modality combinations as well, so the voice of cat with the word cat is a positive sample for speech-text model, a video of cat with the descriptive text “this is a cat” is a positive sample for video-text model.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/easy.png?raw=true&quot; alt=&quot;easy&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;show-time&quot;&gt;Show time&lt;/h3&gt;

&lt;p&gt;Well you don’t have to build that box from scratch because folks have already done it for us. There’s a Multimodal embedding model, like the “ViT-L/14” from OpenAI. This model can handle various data types, including text, images, videos, audios, and even thermal and gyroscope data. Now, onto the next question: how do we store those embeddings?&lt;/p&gt;

&lt;p&gt;For that we’ll need a vector database that can efficiently fetch, query, and retrieve relevant embeddings for us,  ideally one that supports multimodal data and doesn’t burn a hole in our wallets. That’s where LanceDB comes into play.&lt;/p&gt;

&lt;h3 id=&quot;vector-database&quot;&gt;Vector database&lt;/h3&gt;

&lt;p&gt;When we talk about the vector database, there are ton of options available in the current market, but there is something about the LanceDB which makes it stands out as an optimal choice for a vector database, As far as I have used it, it address the limitations of traditional embedded databases in handling AI/ML workloads. When I say traditional, it typically means those database management tools which are not aligned with the usage of heavy computation that comes with the ML infra.&lt;/p&gt;

&lt;p&gt;TLDR; LanceDB operates on a serverless architecture, meaning storage and compute are separated into two distinct units. This design makes it exceptionally fast for RAG use cases, ensuring fast fetching and retrieval. Additionally, it has some notable advantages – being open source, utilizing its Lance columnar data format built on top of Apache Arrow for high efficiency, persistent storage capabilities, and incorporating its own Disk Approximate Nearest Neighbor search. All these factors collectively make LanceDB an ideal solution for accessing and working with multimodal data. I love you LanceDB ❤️.&lt;/p&gt;

&lt;h3 id=&quot;data-time&quot;&gt;Data time&lt;/h3&gt;

&lt;p&gt;To add some excitement, I’ve crafted a GTA-V Image Captioning dataset, featuring thousands of images, each paired with a descriptive text illustrating the image’s content. Now, when we train our magic box, the expectation is clear – if I ask that box to provide me an image of “road with a stop sign,” it should deliver a GTA-V image of a road with a stop sign on it. Otherwise, what’s the point, right?&lt;/p&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;We will be using “ViT-L/14” to convert our multimodal data into its respective embeddings.&lt;/li&gt;
  &lt;li&gt;LanceDB as our vector database to store the relevant embeddings.&lt;/li&gt;
  &lt;li&gt;GTA-V Image Captioning dataset for our magic box.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;environment-setup&quot;&gt;Environment Setup&lt;/h3&gt;

&lt;p&gt;I am using a MacBook Air M1, and it’s important to note that some kinds of dependencies and configurations may vary depending on the type of system that you are running, so it’s important to take that into account.&lt;/p&gt;

&lt;p&gt;Here are the steps to install the relevant dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Create a virtual environment
python3 -m venv env

# Activate the virtual environment
source env/bin/activate

# Upgrade pip in the virtual environment
pip install --upgrade pip

# Install required dependencies
pip3 install lancedb clip torch datasets pillow 
pip3 install git+https://github.com/openai/CLIP.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And don’t forget to get your access token from the hugging face to download the data.&lt;/p&gt;

&lt;h3 id=&quot;downloading-the-data&quot;&gt;Downloading the Data&lt;/h3&gt;
&lt;p&gt;Dataset can easily be fetched using the datasets library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import clip
import torch
import os
from datasets import load_dataset

ds = load_dataset(&quot;vipulmaheshwari/GTA-Image-Captioning-Dataset&quot;)
device = torch.device(&quot;mps&quot;)
model, preprocess = clip.load(&quot;ViT-L-14&quot;, device=device)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Downloading the dataset may require some time, so please take a moment to relax while this process completes. Once the download is finished, you can visualize some sample points like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from textwrap import wrap
import matplotlib.pyplot as plt
import numpy as np

def plot_images(images, captions):
    plt.figure(figsize=(15, 7))
    for i in range(len(images)):
        ax = plt.subplot(1, len(images), i + 1)
        caption = captions[i]
        caption = &quot;\n&quot;.join(wrap(caption, 12))
        plt.title(caption)
        plt.imshow(images[i])
        plt.axis(&quot;off&quot;)

# Assuming ds is a dictionary with &quot;train&quot; key containing a list of samples
sample_dataset = ds[&quot;train&quot;]
random_indices = np.random.choice(len(sample_dataset), size=2, replace=False)
random_indices = [index.item() for index in random_indices]

# Get the random images and their captions
random_images = [np.array(sample_dataset[index][&quot;image&quot;]) for index in random_indices]
random_captions = [sample_dataset[index][&quot;text&quot;] for index in random_indices]

# Plot the random images with their captions
plot_images(random_images, random_captions)

# Show the plot
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/output3.png?raw=true&quot; alt=&quot;output3&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;storing-the-embeddings&quot;&gt;Storing the Embeddings&lt;/h3&gt;

&lt;p&gt;The dataset consists of two key features: the image and its corresponding descriptive text. Initially, our task is to create a LanceDB table to store the embeddings. This process is straightforward – all you need to do is define the relevant schema. In our case, the columns include “vector” for storing the multimodal embeddings, a “text” column for the descriptive text, and a “label” column for the corresponding IDs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pyarrow as pa
import lancedb
import tqdm

db = lancedb.connect(&apos;./data/tables&apos;)
schema = pa.schema(
  [
      pa.field(&quot;vector&quot;, pa.list_(pa.float32(), 512)),
      pa.field(&quot;text&quot;, pa.string()),
      pa.field(&quot;id&quot;, pa.int32())
  ])
tbl = db.create_table(&quot;gta_data&quot;, schema=schema, mode=&quot;overwrite&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing this will generate a table with the specified schema, and it’s ready to store the embeddings along with the relevant columns. It’s as straightforward as that – almost too easy!&lt;/p&gt;

&lt;h3 id=&quot;encode-the-images&quot;&gt;Encode the Images&lt;/h3&gt;

&lt;p&gt;Now, we’ll simply take the images from the dataset, feed them into an encoding function that leverages our Multimodal Embedding model, and generate the corresponding embeddings. These embeddings will then be stored in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def embed_image(img):
    processed_image = preprocess(img)
    unsqueezed_image = processed_image.unsqueeze(0).to(device)
    embeddings = model.encode_image(unsqueezed_image)
    
    # Detach, move to CPU, convert to numpy array, and extract the first element as a list
    result = embeddings.detach().cpu().numpy()[0].tolist()
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So our &lt;code&gt;embed_image&lt;/code&gt; function takes an input image, prepocesses it through our CLIP model preprocessor, encode the preprocessed image and returns a list representing the embeddings of that image. This returned embedding serves as a concise numerical representation, capturing all the key features and patterns within the image for downstream tasks or analysis. The next thing is to call this function for all the images and store the relevant embeddings in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;data = []
for i in range(len(ds[&quot;train&quot;])):
    img = ds[&quot;train&quot;][i][&apos;image&apos;]
    text = ds[&quot;train&quot;][i][&apos;text&apos;]
    
    # Encode the image
    encoded_img = embed_image(img)
    data.append({&quot;vector&quot;: encoded_img, &quot;text&quot;: text, &quot;id&quot; : i})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we’re just taking a list, adding the numeric embeddings, reference text and the current index id to it. All that’s left is to include this list in our LanceDB table. And voila, our datalake for the embeddings is set up and good to go!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;tbl.add(data)
tbl.to_pandas()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Up until now, we’ve efficiently converted the images into their respective multimodal embeddings and stored them in the LanceDB table. Now the LanceDB tables offer a convenient feature: if there’s a need to add or remove images, it’s remarkably straightforward. Just encode the new image and add it, following to the same steps we followed for the previous images.&lt;/p&gt;

&lt;h3 id=&quot;query-search&quot;&gt;Query search&lt;/h3&gt;

&lt;p&gt;Our next move is to embed our text query using the same multimodal embedding model we used for our images. Remember that “box” I mentioned earlier? Essentially, we want this box to create embeddings for both our images and our texts which ensures that the representation of different types of data happens in the same way. Following this, we just need to initiate a search to find the nearest image embeddings that matches our text query.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
def embed_txt(txt):
    tokenized_text = clip.tokenize([txt]).to(device)
    embeddings = model.encode_text(tokenized_text)
    
    # Detach, move to CPU, convert to numpy array, and extract the first element as a list
    result = embeddings.detach().cpu().numpy()[0].tolist()
    return result

res = tbl.search(embed_txt(&quot;a road with a stop&quot;)).limit(3).to_pandas()
res
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;0 | [0.064575195, .. ] | there is a stop sign...| 569 |	131.995728
1 | [-0.07989502, .. ] | there is a bus that... | 423 | 135.047852
2 | [0.06756592, .. ]  | amazing view of a ...	| 30  | 135.309937
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s slow down a bit and understand what just happened. Putting simply, the code snippet executes a search algorithm in its core to pinpoint the most relevant image embedding that aligns with our text query. The resulting output, as showcased above, gives us the embeddings which closely resembles our text query.  In the result, the second column presents the embedding vector, while the third column contains the description of the image that closely matches our text query. Essentially, we’ve determined which image closely corresponds to our text query by examining the embeddings of both our text query and the image.&lt;/p&gt;

&lt;h3 id=&quot;its-similar-to-saying-if-these-numbers-represent-the-word-cat-i-spot-an-image-with-a-similar-set-of-numbers-so-most-likely-its-a-match-for-an-image-of-a-cat-&quot;&gt;It’s similar to saying, If these numbers represent the word “Cat”, I spot an image with a similar set of numbers, so most likely it’s a match for an image of a “Cat”. 😺&lt;/h3&gt;

&lt;p&gt;If you are looking for the explanation of how the search happens, I will write a detailed explanation in the coming write ups because it’s so exciting to look under the hood and see how the searching happens. Essentially there is something called Approximate Nearest Neighbors (ANN) which is a technique used to efficiently find the closest points in high-dimensional spaces. ANN is extensively used in data mining, machine learning, computer vision and NLP use cases. So when we passed our embedded text query to the searching algorithm and asked it to give us the closest sample point in the vector space, it used a type of ANN algorithm to get it for us. Specifically LanceDB utilizes DANN (Deep Approximate Nearest Neighbor) for searching the relevant embeddings within its ecosystem..&lt;/p&gt;

&lt;p&gt;In our results, we have five columns. The first is the index number, the second is the embedding vector, the third is the description of the image matching our text query, and the fourth is the label of the image. However, let’s focus on the last column – Distance. When I mentioned the ANN algorithm, it simply draws a line between the current data point (in our case, the embedding of our text query) and identifies which data point (image embedding) is closest to it. If you observe that the other data points in the results have a greater distance compared to the top one, it indicates they are a bit further away or more unrelated to our query. Just to make it clear, the calculation of distance is a part of the algorithm itself.&lt;/p&gt;

&lt;h2 id=&quot;d-day&quot;&gt;D-DAY&lt;/h2&gt;

&lt;p&gt;Now that we have all the necessary information, displaying the most relevant image for our query is straightforward. Simply take the relevant label of the top-matched embedding vector and showcase the corresponding image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;data_id = int(res[&apos;id&apos;][0])
display(ds[&quot;train&quot;][data_id][&apos;image&apos;])
print(ds[&quot;train&quot;][data_id][&apos;text&apos;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/output_final.png?raw=true&quot; alt=&quot;output_final&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;there is a truck driving down a street with a stop sign
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h3&gt;

&lt;p&gt;To make things more interesting, I’m currently working on creating an extensive GTA-V captioning dataset. This dataset will include a larger number of images paired with their respective reference text, providing us with a richer set of queries to explore and experiment with.. Nevertheless, there’s always room for refining the model. We can explore creating a customized CLIP model, adjusting various parameters. Increasing the number of training epochs may afford the model more time to grasp the relevance between embeddings. Additionally, there’s an impressive multimodal embedding model developed by the Meta known as &lt;a href=&quot;https://imagebind.metademolab.com/&quot;&gt;ImageBind&lt;/a&gt;. We can consider trying ImageBind as an alternative to our current multimodal embedding model and compare the outcomes. With numerous options available, the fundamental concept behind the Multimodal RAG workflow remains largely consistent.&lt;/p&gt;

&lt;p&gt;Here’s how everything comes together in one frame and this is the &lt;a href=&quot;https://colab.research.google.com/drive/1LM-WrDSBXpiMZ94CtaMCaGHlkxqGR6WK?usp=sharing&quot;&gt;Collab&lt;/a&gt; for your reference&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/multimodal_rag/multimodalrag.png?raw=true&quot; alt=&quot;multimodal_rag&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Create LLM apps using RAG</title>
   <link href="http://localhost:4000/2024/02/14/rag-application-with-langchain"/>
   <updated>2024-02-14T00:00:00+05:30</updated>
   <id>http://localhost:4000/2024/02/14/rag-application-with-langchain</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/cat.png?raw=true&quot; alt=&quot;cat&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If you’re considering making a personalized bot for your documents or your website that responds to you, you’re in the right spot. I’m here to help you create a bot using Langchain and RAG strategies for this purpose.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;understanding-the-limitations-of-chatgpt-and-llms&quot;&gt;Understanding the Limitations of ChatGPT and LLMs&lt;/h3&gt;

&lt;p&gt;ChatGPTs and other Large Language Models (LLMs) are extensively trained on text corpora to comprehend language semantics and coherence. Despite their impressive capabilities, these models have limitations that require careful consideration for particular use cases. One significant challenge is the potential for hallucinations, where the model might generate inaccurate or contextually irrelevant information.&lt;/p&gt;

&lt;p&gt;Imagine requesting the model to enhance your company policies; in such scenarios, ChatGPTs and other Large Language Models might struggle to provide factual responses because they lack training on your company’s data. Instead, they may generate nonsensical or irrelevant responses, which can be unhelpful. So, how can we ensure that an LLM comprehends our specific data and generates responses accordingly? This is where techniques like Retrieval Augmentation Generation (RAG) come to the rescue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/LLM_without_RAG.png?raw=true&quot; alt=&quot;RAG&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;what-is-rag&quot;&gt;What is RAG?&lt;/h3&gt;
&lt;p&gt;RAG or Retrieval Augmented Generation uses three main workflows to generate and give the better response&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Information Retrieval: When a user asks a question, the AI system retrieves the relevant data from a well-maintained knowledge library or external sources like databases, articles, APIs, or document repositories. This is achieved by converting the query into a numerical format or vector that can be understood by machines.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LLM:The retrieved data is then presented to the LLM or Large Language Model, along with the user’s query. The LLM uses this new knowledge and its training data to generate the response.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Response: Finally, the LLM generates a response that is more accurate and relevant since it has been augmented with the retrieved information. I mean we gave LLM some additional information from our Knowledge library which allows LLMs to provide more contextually relevant and factual responses, solving the problem of models when they are just hallucinating or providing irrelevant answers.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s take the example of company policies again. Suppose you have an HR bot that handles queries related to your Company policies. Now if someone asks anything specific to the policies, The bot can pull the most recent policy documents from the knowledge library, pass the relevant context to a well crafted prompt which is then passed further to the LLM for generating the response.&lt;/p&gt;

&lt;p&gt;To make it easier, Imagine a LLM as your knowledgeable friend who seems to know everything, from Geography to Computer Science, from Politics to Philosophy. Now, picture yourself asking this friend a few questions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Who handles my laundry on weekends?”&lt;/li&gt;
  &lt;li&gt;“Who lives next door to me?”&lt;/li&gt;
  &lt;li&gt;“What brand of peanut butter do I prefer?”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chances are, your friend wouldn’t be able to answer these questions. Most of the time, no. But let’s say this distant friend becomes closer to you over time, he comes to your place regularly, knows your parents very well, you both hangout pretty often, you go on outings, blah blah blah.. You got the point.&lt;/p&gt;

&lt;p&gt;I mean he is gaining access to personal and insider information about you.  Now, when you pose the same questions, he can somehow answer those questions with more relevance now because he is better suited with your personal insights.&lt;/p&gt;

&lt;p&gt;Similarly, a LLM, when provided with additional information or access to your data, won’t guess or hallucinate. Instead, it can leverage that access data to provide more relevant and accurate answers.&lt;/p&gt;

&lt;h3 id=&quot;to-break-it-down-here-are-the-exact-steps-to-create-any-rag-application&quot;&gt;To break it down, here are the exact steps to create any RAG application…&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Extract the relevant information from your data sources.&lt;/li&gt;
  &lt;li&gt;Break the information into the small chunks.&lt;/li&gt;
  &lt;li&gt;Store the chunks as their embedddings into a vector database.&lt;/li&gt;
  &lt;li&gt;Create a prompt template which will be fed to the LLM with the query and the context.&lt;/li&gt;
  &lt;li&gt;Convert the query to it’s relevant embedding using same embedding model.&lt;/li&gt;
  &lt;li&gt;Fetch k number of relevant documents related to the query from the vector database.&lt;/li&gt;
  &lt;li&gt;Pass the relevant documents to the LLM and get the response.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;faqs&quot;&gt;FAQs&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;We will be using &lt;a href=&quot;https://python.langchain.com/docs/get_started/introduction&quot;&gt;Langchain&lt;/a&gt; for this task, Basically it’s like a wrapper which lets you talk and manage your LLM operations better. Note that the Langchain is updating very fast and some functions and other classes might moved to the different modules. So if something doesn’t work, just check if you are importing the libraries from the right sources!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Along with it we will be using &lt;a href=&quot;https://huggingface.co/&quot;&gt;Hugging Face&lt;/a&gt;, an open-source library for building, training, and deploying state-of-the-art machine learning models, especially about NLP. To use the HuggingFace we need the access token, Get your access token &lt;a href=&quot;https://huggingface.co/docs/hub/security-tokens&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For our models, we’ll need two key components: a LLM (Large Language Model) and an embedding model. While paid sources like OpenAI offer these, we’ll be utilizing open-source models to ensure accessibility for everyone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now we need a Vector Database to store our embeddings, For that task, we’ve got &lt;a href=&quot;https://lancedb.com/&quot;&gt;LanceDB&lt;/a&gt; – it’s like a super-smart data lake for handling lots of information. It’s a top-notch vector database, making it the go-to choice for dealing with complex data like vector embeddings.. And the best part? It won’t burn a dent in your pocket because it’s open source and free to use!!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To keep things simple, our data ingestion process will involve using a URL and some PDFs. While you can incorporate additional data sources if needed, we’ll concentrate solely on these two for now.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With Langchain for the interface, Hugging Face for fetching the models, along with open-source components, we’re all set to go! This way, we will save some bucks while still having everything we need. Let’s move to the next steps&lt;/p&gt;

&lt;h3 id=&quot;environment-setup&quot;&gt;Environment Setup&lt;/h3&gt;

&lt;p&gt;I am using a MacBook Air M1, and it’s important to note that certain dependencies and configurations may vary depending on the type of system you are using. Now open your favorite editor, create a python environment and install the relevant dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Create a virtual environment
python3 -m venv env

# Activate the virtual environment
source env/bin/activate

# Upgrade pip in the virtual environment
pip install --upgrade pip

# Install required dependencies
pip3 install lancedb langchain langchain_community prettytable sentence-transformers huggingface-hub bs4 pypdf pandas

# This is optional, I did it for removing a warning
pip3 uninstall urllib3
pip3 install &apos;urllib3&amp;lt;2.0&apos;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a .env file in the same directory to place your Hugging Face api credentials like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;HUGGINGFACEHUB_API_TOKEN = hf_KKNWfBqgwCUOHdHFrBwQ.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensure the name “HUGGINGFACEHUB_API_TOKEN” remains unchanged, as it is crucial for authentication purposes.&lt;/p&gt;

&lt;p&gt;If you prefer a straightforward approach without relying on external packages or file loading, you can directly configure the environment variable within your code like this..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;HF_TOKEN = &quot;hf_KKNWfBqgwCUOHdHFrBwQ.....&quot;
os.environ[&quot;HUGGINGFACEHUB_API_TOKEN&quot;] = HF_TOKEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally create a data folder in the project’s root directory, designated as the central repository for storing PDF documents. You can add some sample PDFs for testing purposes; for instance, I am using the &lt;a href=&quot;https://arxiv.org/pdf/2207.02696.pdf&quot;&gt;Yolo V7&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot;&gt;Transformers&lt;/a&gt; paper for demonstration. It’s important to note that this designated folder will function as our primary source for data ingestion.&lt;/p&gt;

&lt;p&gt;It seems like everything is in order, and we’re all set!&lt;/p&gt;

&lt;h3 id=&quot;step-1--extracting-the-relevant-information&quot;&gt;Step 1 : Extracting the relevant information&lt;/h3&gt;

&lt;p&gt;To get your RAG application running, the first thing we need to do is to extract the relevant information from the various data sources. It can be a website page, a PDF file, a notion link, a google doc whatever it is, it needs to be extracted from it’s original source first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import os
from langchain_community.document_loaders import WebBaseLoader, PyPDFLoader, DirectoryLoader

# Put the token values inside the double quotes
HF_TOKEN = &quot;hf_*******&quot;
os.environ[&quot;HUGGINGFACEHUB_API_TOKEN&quot;] = HF_TOKEN

# Loading the web url and data 
url_loader = WebBaseLoader(&quot;https://gameofthrones.fandom.com/wiki/Jon_Snow&quot;)
documents_loader = DirectoryLoader(&apos;data&apos;, glob=&quot;./*.pdf&quot;, loader_cls=PyPDFLoader)

# Creating the instances
url_docs = url_loader.load()
data_docs = documents_loader.load()

# Combining all the data that we ingested
docs = url_docs + data_docs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will ingest all the data from the URL link and the PDFs.&lt;/p&gt;

&lt;h3 id=&quot;step-2--breaking-the-information-into-smaller-chunks&quot;&gt;Step 2 : Breaking the information into smaller chunks&lt;/h3&gt;

&lt;p&gt;We’ve all the necessary data for developing our RAG application. Now, it’s time to break down this information into smaller chunks. Later, we’ll utilize an embedding model to convert these chunks into their respective embeddings. But why is it important?&lt;/p&gt;

&lt;p&gt;Think of it like this: If you’re tasked with digesting a 100-page book all at once and then asked a specific question about it, it would be challenging to retrieve the necessary information from the entire book to provide an answer. However, if you’re permitted to break the book into smaller, manageable chunks—let’s say 10 pages each—and each chunk is labeled with an index from 0 to 9, the process becomes much simpler. When the same question is posed after this breakdown, you can easily locate the relevant chunk based on its index and then extract the information needed to answer the question accurately.&lt;/p&gt;

&lt;p&gt;Picture the book as your extracted information, with each 10-page segment representing a small chunk of data, and the index pages as the embedding. Essentially, we’ll apply an embedding model to these chunks to transform the information into their respective embeddings. While as humans, we may not directly comprehend or relate to these embeddings, they serve as numeric representations of the chunks to our application.  This is how you can do this in Python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from langchain.text_splitter import RecursiveCharacterTextSplitter

text_splitter = RecursiveCharacterTextSplitter(chunk_size = 1000, chunk_overlap = 50)
chunks = text_splitter.split_documents(docs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the chunk_size parameter specifies the maximum number of characters that a chunk can contain, while the chunk_overlap parameter specifies the number of characters that should overlap between two adjacent chunks. With the chunk_overlap set to 50, the last 50 characters of the adjacent chunks will be shared between each other.&lt;/p&gt;

&lt;p&gt;This approach helps to prevent important information from being split across two chunks, ensuring that each chunk contains sufficient contextual information of their neighbor chunks for the subsequent processing or analysis.&lt;/p&gt;

&lt;p&gt;Shared information at the boundary of neighboring chunks enables a more seamless transition and understanding of the text’s content. The best strategy for choosing the chunk_size and chunk_overlap parameters largely depends on the nature of the documents and the purpose of the application.&lt;/p&gt;

&lt;h3 id=&quot;step-3--creating-the-embeddings-and-store-them-into-a-vectordatabase&quot;&gt;Step 3 : Creating the embeddings and store them into a vectordatabase&lt;/h3&gt;

&lt;p&gt;There are two primary methods to generate embeddings for our text chunks. The first involves downloading a model, managing preprocessing, and conducting computations independently. Alternatively, we can leverage Hugging Face’s model hub, which offers a variety of pre-trained models for various NLP tasks, including embedding generation.&lt;/p&gt;

&lt;p&gt;Opting for the latter approach allows us to utilize one of Hugging Face’s embedding models. With this method, we simply provide our text chunks to the chosen model, saving us from the resource-intensive computations on our local machines. 💀&lt;/p&gt;

&lt;p&gt;Hugging Face’s model hub provides numerous options for embedding models, and you can explore the &lt;a href=&quot;https://huggingface.co/spaces/mteb/leaderboard&quot;&gt;leaderboard&lt;/a&gt; to select the most suitable one for your requirements. For now, we’ll proceed with “sentence-transformers/all-MiniLM-L6-v2.” This model is pretty fast and highly efficient in our task!!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from langchain_community.embeddings import HuggingFaceEmbeddings

embedding_model_name = &apos;sentence-transformers/all-MiniLM-L6-v2&apos;
embeddings = HuggingFaceEmbeddings(model_name=embedding_model_name, model_kwargs={&apos;device&apos;: &apos;cpu&apos;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s a way to see the number of embeddings for each chunk&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;query = &quot;Hello I want to see the length of the embeddings for this document.&quot;
len(embeddings.embed_documents([query])[0])

# 384
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have the embeddings for our chunks, now we need a vector database to store them.&lt;/p&gt;

&lt;p&gt;When it comes to vector databases, there are plenty of options out there suiting various needs. Databases like Pinecone offer adequate performance and advanced features but come with a hefty price tag. On the other hand, open-source alternatives like FAISS or Chroma may lack some extras but are more than sufficient for those not who don’t require extensive scalability.&lt;/p&gt;

&lt;p&gt;But wait, I am dropping a bomb here, I’ve recently come across LanceDB, So it’s an open-source vector database similar to FAISS and Chroma. What makes LanceDB stand out is not just its open-source nature but its unparalleled scalability. In fact, after a closer look, I realized that I haven’t done justice in highlighting the true value propositions of LanceDB earlier!!&lt;/p&gt;

&lt;p&gt;Surprisingly, LanceDB is the most scalable vector database available, outperforming even the likes of Pinecone, Chroma, Qdrant, and others. Scaling up to a billion vectors locally on your laptop is a feat only achievable with LanceDB. I mean this capability is a game-changer, especially when you compare it to other vector databases struggling even with a hundred million vectors. What’s more mind blowing is that LanceDB manages to offer this unprecedented scalability at a fraction of cost, I mean they are offering the utilities and database tools at much cheaper rates than its closest counterparts.&lt;/p&gt;

&lt;p&gt;So now, We’ll create an instance of LanceDB vector database by calling &lt;code&gt;lancedb.connect(&quot;lance_database&quot;)&lt;/code&gt;. This line essentially sets up a connection to the LanceDB database named “lance_database.” Next, we create a table within the database named “rag_sample” using the create_table function. Now we initialzed this table with a single data entry which includes a numeric vector generated by the embed_query function. So text “Hello World” is first converted to it’s numeric representation (fancy name of embeddings) and then it’s mapped to &lt;code&gt;id&lt;/code&gt; number 1. Like a key-value pair. Lastly, the mode=”overwrite” parameter ensures that if the table “rag_sample” already exists, it will be overwritten with the new data.&lt;/p&gt;

&lt;p&gt;This happens with all the text chunks and it’s quite straightforward. This is how it looks in Python..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import lancedb
from langchain_community.vectorstores import LanceDB

db = lancedb.connect(&quot;lance_database&quot;)
table = db.create_table(
    &quot;rag_sample&quot;,
    data=[
        {
            &quot;vector&quot;: embeddings.embed_query(&quot;Hello World&quot;),
            &quot;text&quot;: &quot;Hello World&quot;,
            &quot;id&quot;: &quot;1&quot;,
        }
    ],
    mode=&quot;overwrite&quot;,
)

docsearch = LanceDB.from_documents(chunks, embeddings, connection=table)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NO ROCKET SCIENCE HA!&lt;/p&gt;

&lt;h3 id=&quot;step-4--create-a-prompt-template-which-will-be-fed-to-the-llm&quot;&gt;Step 4 : Create a prompt template which will be fed to the LLM&lt;/h3&gt;

&lt;p&gt;Ok now comes the prompt template. So when you write a question to the ChatGPT and it answers that question, you are basically providing a prompt to the model so that it can understand what the question is. When companies train the models, they decide what kind of prompt they are going to use for invoking the model and ask the question. For example, if you are working with “Mistral 7B instruct” and you want the optimal results it’s recommended to use the following chat template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;&amp;lt;s&amp;gt;[INST] Instruction [/INST] Model answer&amp;lt;/s&amp;gt;[INST] Follow-up instruction [/INST]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &amp;lt;s&amp;gt; and &amp;lt;/s&amp;gt; are special tokens to represent beginning of string (BOS) and end of string (EOS) while [INST] and [/INST] are regular strings. It’s just that the Mistral 7B instruct is made in such a way that the model looks for those special tokens to understand the question better. Different types of LLMs have different kinds of instructed prompts.&lt;/p&gt;

&lt;p&gt;Now for our case we are going to use &lt;a href=&quot;https://huggingface.co/HuggingFaceH4/zephyr-7b-alpha&quot;&gt;huggingfaceh4/zephyr-7b-alpha&lt;/a&gt; which is a text generation model. Just to make it clear, Zephyr-7B-α has not been aligned or formated to human preferences with techniques like RLHF (Reinforcement Learning with Human Feedback) or deployed with in-the-loop filtering of responses like ChatGPT, so the model can produce problematic outputs (especially when prompted to do so).&lt;/p&gt;

&lt;p&gt;Instead of writing a Prompt of our own, I will use ChatPromptTemplate class which creates a prompt template for the chat models. In layman terms, instead of writing a specified prompt I am letting ChatPromptTemplate to do it for me. Here is an example prompt template that is being generated from the manual messsages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from langchain_core.prompts import ChatPromptTemplate

chat_template = ChatPromptTemplate.from_messages(
    [
        (&quot;system&quot;, &quot;You are a helpful AI bot. Your name is {name}.&quot;),
        (&quot;human&quot;, &quot;Hello, how are you doing?&quot;),
        (&quot;ai&quot;, &quot;I&apos;m doing well, thanks!&quot;),
        (&quot;human&quot;, &quot;{user_input}&quot;),
    ]
)

messages = chat_template.format_messages(name=&quot;Bob&quot;, user_input=&quot;What is your name?&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don’t want to write the manual instructions, you can just use the &lt;em&gt;from_template&lt;/em&gt; function to generate a more generic prompt template which I used for this project. Here it is..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from langchain_core.prompts import ChatPromptTemplate

template = &quot;&quot;&quot;
{query}
&quot;&quot;&quot;

prompt = ChatPromptTemplate.from_template(template)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our prompt is set! We’ve crafted a single message, assuming it’s from a human xD . If you’re not using the from_messages function, the ChatPromptTemplate will ensure your prompt works seamlessly with the language model by reserving some additional system messages. There’s always room for improvement with more generic prompts to achieve better results. For now this setup should work..&lt;/p&gt;

&lt;h3 id=&quot;step-5--convert-the-query-to-its-relevant-embedding-using-same-embedding-model&quot;&gt;Step 5 : Convert the query to it’s relevant embedding using same embedding model.&lt;/h3&gt;

&lt;p&gt;Now, let’s talk about the query or question we want to ask our RAG application. We can’t just pass the query to our model and expect information in return. Instead, we need to pass the query through the same embedding model used for the chunks earlier. Why is this important? Well, by embedding queries, we allow models to compare them efficiently with previously processed chunks of text. This enables tasks like finding similar documents or generating relevant responses.&lt;/p&gt;

&lt;p&gt;To understand it better, Imagine you and your friend speak different languages, like English and Hindi, and you need to understand each other’s writings. If your friend hands you a page in Hindi, you won’t understand it directly. So, your friend translates it first, turning the Hindi into English for you. So now if your friend asks you a question in Hindi, you can easily translate that question into English first and look up for the relevant answers in that translated English Text..&lt;/p&gt;

&lt;p&gt;Similarly, we initially transformed textual information into their corresponding embeddings. Now,  when you pose a query, it undergoes a similar kind of conversion into the numeric form using the same embedding model applied previously to process our textual chunks. This consistent approach allows for efficient retrieval of relevant responses.&lt;/p&gt;

&lt;h3 id=&quot;step-6--fetch-k-number-of-documents&quot;&gt;Step 6 : Fetch K number of documents.&lt;/h3&gt;

&lt;p&gt;Now, let’s talk about the retriever. Its job is to dive into the vector database and perform a search to find relevant documents. It returns a set number, let’s call it “k”, of these documents, which are ranked based on their contextual relevance to the query or question you asked. You can set “k” as a parameter, indicating how many relevant documents you want - whether it’s 2, 5, or 10. Generally, if you have a smaller amount of data, it’s best to stick with a lower “k”, around 2. For longer documents or larger datasets, a “k” between 10 and 20 is recommended.&lt;/p&gt;

&lt;p&gt;Different &lt;a href=&quot;https://python.langchain.com/docs/modules/data_connection/retrievers/vectorstore&quot;&gt;search techniques&lt;/a&gt; can be employed to fetch relevant documents more effectively and quickly from a vector database. The choice depends on various factors such as your specific use case, the amount of data you have, what kind of vector database you are using and the context of your problem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;retriever = docsearch.as_retriever(search_kwargs={&quot;k&quot;: 3})
docs = retriever.get_relevant_documents(&quot;what did you know about Yolo V7?&quot;)
print(docs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this code, the retriever will fetch 3 most most relevant documents from the vector database. All these documents will be the contexts for our LLM model to generate the response for our query.&lt;/p&gt;

&lt;h3 id=&quot;step-7--pass-the-relevant-documents-to-the-llm-and-get-the-response&quot;&gt;Step 7 : Pass the relevant documents to the LLM and get the response.&lt;/h3&gt;

&lt;p&gt;So far, we’ve asked our retriever to fetch a set number of relevant documents from the database. Now, we need a language model (LLM) to generate a relevant response based on that context. To ensure robustness, let’s remember that at the beginning of this blog, I mentioned that LLMs like ChatGPT can sometimes generate irrelevant responses, especially when asked about specific use cases or contexts. However, this time, we’re providing the context from our own data to the LLM as a reference. So, it will consider this reference along with its general capabilities to answer the question. That’s the whole idea behind using RAG!&lt;/p&gt;

&lt;p&gt;Now, let’s dive into implementing the language model (LLM) aspect of our RAG setup. We’ll be using zephyr model architecture from the Hugging Face Hub. Here’s how we do it in Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from langchain_community.llms import HuggingFaceHub

# Model architecture
llm_repo_id = &quot;huggingfaceh4/zephyr-7b-alpha&quot;
model_kwargs = {&quot;temperature&quot;: 0.5, &quot;max_length&quot;: 4096, &quot;max_new_tokens&quot;: 2048}
model = HuggingFaceHub(repo_id=llm_repo_id, model_kwargs=model_kwargs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code snippet, we’re instantiating our language model using the Hugging Face Hub. Specifically, we’re selecting the zephyr 7 billion model which is placed in this repository ID &lt;a href=&quot;https://huggingface.co/HuggingFaceH4/zephyr-7b-alpha&quot;&gt;“huggingfaceh4/zephyr-7b-alpha”&lt;/a&gt;. Choosing this model isn’t arbitrary; as I said before, it’s based on the model’s suitability for our specific task and requirements. As we are already implementing only Open Source components, Zephyr 7 billion works good enough to generate a useful response with minimal overhead and low latency.&lt;/p&gt;

&lt;p&gt;This model comes with some additional parameters to fine-tune its behavior. We’ve set the temperature to 0.5, which controls the randomness of the generated text. As a lower temperature tends to result in more conservative and predictable outputs and when the temperature is set to max which is 1, the model tries to be as creative as it could, so based on what type of output you want for your use case, you can tweak this parameter. For the sake of the simplicity and demonstration purposes, I set it to 0.5 to make sure we get decent results. Next is max_length parameter which defines the maximum length of the generated text and it includes the size of your prompt as well as the response.&lt;/p&gt;

&lt;p&gt;max_new_tokens sets the threshold on the maximum number of new tokens that can be generated. As a general rule of thumb, the max_new_tokens should always be less than or equal to the max_length parameter. Why? Think about it..&lt;/p&gt;

&lt;h3 id=&quot;step-8--create-a-chain-for-invoking-the-llm&quot;&gt;Step 8 : Create a chain for invoking the LLM.&lt;/h3&gt;

&lt;p&gt;We have everything we want for our RAG application. The last thing we need to do is to create a chain for invoking the LLM on our query to generate the response. There are different types of chains for the different types of use cases, if you like your LLM to remember the context of the chat over the time like the ChatGPT , you would need a memory instance which can be shared among multiple conversation pieces, for such cases, there are conversational chains available.&lt;/p&gt;

&lt;p&gt;For now we just need a chain which can combine our retrieved contexts and pass it with the query to the LLM to generate the response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough

rag_chain = (
    {&quot;context&quot;: retriever,  &quot;query&quot;: RunnablePassthrough()}
    | prompt
    | model
    | StrOutputParser()
)

response = rag_chain.invoke(&quot;Who killed Jon Snow?&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have our Prompt, model, context and the query! All of them are combined into a single chain. It’s pretty much what all the chains does! Now before running the final code, I want to give a quick check on these two helper functions: 
&lt;code&gt;RunnablePassthrough()&lt;/code&gt; and &lt;code&gt;StrOutputParser()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;RunnablePassthrough&lt;/code&gt; class in &lt;code&gt;LangChain&lt;/code&gt; serves to pass inputs unchanged or with additional keys. In our chain, a prompt expects input in the form of a map with keys “context” and “question.” However, user input only includes the “question.” or the “query”.  Here, &lt;code&gt;RunnablePassthrough&lt;/code&gt; is utilized to pass the user’s question under the “question” key while retrieving the context using a retriever. It just ensures that the input to the prompt conforms to the expected format.&lt;/p&gt;

&lt;p&gt;Secondally, &lt;code&gt;StrOutputParser&lt;/code&gt; is typically employed in RAG chains to parse the output of the model into a human-readable string. In the layman terms, It is responsible for transforming the model’s output into a more coherent and grammatically correct sentence, which is generally better readable by Humans! That’s it!&lt;/p&gt;

&lt;h3 id=&quot;d-day&quot;&gt;D-Day&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/LLM_with_RAG.png?raw=true&quot; alt=&quot;With_RAG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To make sure we get the entire idea even if the response gets cut off, I’ve implemented a function called &lt;code&gt;get_complete_sentence()&lt;/code&gt;. Basically this function helps extract the last complete sentence from the text. So, even if the response hits the maximum token limit that we set upon and it gets truncated midway, we will still get a coherent understanding of the message.&lt;/p&gt;

&lt;p&gt;For practical testing, I suggest storing some low sized PDFs in the data folder of your project. You can choose PDFs related to various topics or domains that you want the chatbot to interact with. Additionally, providing a URL as a reference for the chatbot can be helpful for testing. For example, you could use a Wikipedia page, a research paper, or any other online document relevant to your testing goals. During my testing, I used a URL containing information about Jon Snow from Game of Thrones,  and PDFs of Transformers paper, and the YOLO V7 paper to evaluate the bot’s performance. Let’s see how our bot performs in varied content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import os
import time
import lancedb
from langchain_community.vectorstores import LanceDB

from langchain_community.llms import HuggingFaceHub
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import LanceDB
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.document_loaders import WebBaseLoader, PyPDFLoader, DirectoryLoader
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from prettytable import PrettyTable

HF_TOKEN = &quot;hf*********&quot;
os.environ[&quot;HUGGINGFACEHUB_API_TOKEN&quot;] = HF_TOKEN

# Loading the web URL and breaking down the information into chunks
start_time = time.time()

loader = WebBaseLoader(&quot;https://gameofthrones.fandom.com/wiki/Jon_Snow&quot;)
documents_loader = DirectoryLoader(&apos;data&apos;, glob=&quot;./*.pdf&quot;, loader_cls=PyPDFLoader)

# URL loader
url_docs = loader.load()

# Document loader
data_docs = documents_loader.load()

# Combining all the information into a single variable
docs = url_docs + data_docs

# Specify chunk size and overlap
chunk_size = 256
chunk_overlap = 20
text_splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)
chunks = text_splitter.split_documents(docs)

# Specify Embedding Model
embedding_model_name = &apos;sentence-transformers/all-MiniLM-L6-v2&apos;
embeddings = HuggingFaceEmbeddings(model_name=embedding_model_name, model_kwargs={&apos;device&apos;: &apos;cpu&apos;})

# Specify Vector Database
vectorstore_start_time = time.time()
database_name = &quot;LanceDB&quot;
db = lancedb.connect(&quot;src/lance_database&quot;)
table = db.create_table(
    &quot;rag_sample&quot;,
    data=[
        {
            &quot;vector&quot;: embeddings.embed_query(&quot;Hello World&quot;),
            &quot;text&quot;: &quot;Hello World&quot;,
            &quot;id&quot;: &quot;1&quot;,
        }
    ],
    mode=&quot;overwrite&quot;,
)
docsearch = LanceDB.from_documents(chunks, embeddings, connection=table)
vectorstore_end_time = time.time()

# Specify Retrieval Information
search_kwargs = {&quot;k&quot;: 3}
retriever = docsearch.as_retriever(search_kwargs = {&quot;k&quot;: 3})

# Specify Model Architecture
llm_repo_id = &quot;huggingfaceh4/zephyr-7b-alpha&quot;
model_kwargs = {&quot;temperature&quot;: 0.5, &quot;max_length&quot;: 4096, &quot;max_new_tokens&quot;: 2048}
model = HuggingFaceHub(repo_id=llm_repo_id, model_kwargs=model_kwargs)

template = &quot;&quot;&quot;
{query}
&quot;&quot;&quot;

prompt = ChatPromptTemplate.from_template(template)

rag_chain_start_time = time.time()
rag_chain = (
    {&quot;context&quot;: retriever, &quot;query&quot;: RunnablePassthrough()}
    | prompt
    | model
    | StrOutputParser()
)
rag_chain_end_time = time.time()

def get_complete_sentence(response):
    last_period_index = response.rfind(&apos;.&apos;)
    if last_period_index != -1:
        return response[:last_period_index + 1]
    else:
        return response

# Invoke the RAG chain and retrieve the response
rag_invoke_start_time = time.time()
response = rag_chain.invoke(&quot;Who killed Jon Snow?&quot;)
rag_invoke_end_time = time.time()

# Get the complete sentence
complete_sentence_start_time = time.time()
complete_sentence = get_complete_sentence(response)
complete_sentence_end_time = time.time()

# Create a table
table = PrettyTable()
table.field_names = [&quot;Task&quot;, &quot;Time Taken (Seconds)&quot;]

# Add rows to the table
table.add_row([&quot;Vectorstore Creation&quot;, round(vectorstore_end_time - vectorstore_start_time, 2)])
table.add_row([&quot;RAG Chain Setup&quot;, round(rag_chain_end_time - rag_chain_start_time, 2)])
table.add_row([&quot;RAG Chain Invocation&quot;, round(rag_invoke_end_time - rag_invoke_start_time, 2)])
table.add_row([&quot;Complete Sentence Extraction&quot;, round(complete_sentence_end_time - complete_sentence_start_time, 2)])

# Additional information in the table
table.add_row([&quot;Embedding Model&quot;, embedding_model_name])
table.add_row([&quot;LLM (Language Model) Repo ID&quot;, llm_repo_id])
table.add_row([&quot;Vector Database&quot;, database_name])
table.add_row([&quot;Temperature&quot;, model_kwargs[&quot;temperature&quot;]])
table.add_row([&quot;Max Length Tokens&quot;, model_kwargs[&quot;max_length&quot;]])
table.add_row([&quot;Max New Tokens&quot;, model_kwargs[&quot;max_new_tokens&quot;]])
table.add_row([&quot;Chunk Size&quot;, chunk_size])
table.add_row([&quot;Chunk Overlap&quot;, chunk_overlap])
table.add_row([&quot;Number of Documents&quot;, len(docs)])


print(&quot;\nComplete Sentence:&quot;)
print(complete_sentence)

# Print the table
print(&quot;\nExecution Timings:&quot;)
print(table)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To enhance readability and present the execution information in a structured tabular format, I have used &lt;code&gt;PrettyTable&lt;/code&gt; library. You can add it to your virtual environment by using the command &lt;code&gt;pip3 install prettytable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So this is the response I received in less than &amp;lt; 1 minute, which is quite considerable for the starters. The time it takes can vary depending on your system’s configuration, but I believe you’ll get decent results in just a few minutes. So, please be patient if it’s taking a bit longer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;Human: 
Question : Who killed Jon Snow?

Answer: 
In the TV series Game of Thrones, Jon Snow was stabbed by his 
fellow Night&apos;s Watch members in season 5, episode 9, 
&quot;The Dance of Dragons.&quot; However, he was later resurrected by Melisandre 
in season 6, episode 3, &quot;Oathbreaker.&quot; So, technically, 
no one killed Jon Snow in the show.


Execution Timings:
+------------------------------+----------------------------------------+
|             Task             |          Time Taken (Seconds)          |
+------------------------------+----------------------------------------+
|     Vectorstore Creation     |                 16.21                  |
|       RAG Chain Setup        |                  0.03                  |
|     RAG Chain Invocation     |                  2.06                  |
| Complete Sentence Extraction |                  0.0                   |
|       Embedding Model        | sentence-transformers/all-MiniLM-L6-v2 |
| LLM (Language Model) Repo ID |     huggingfaceh4/zephyr-7b-alpha      |
|       Vector Database        |                LanceDB                 |
|         Temperature          |                  0.5                   |
|      Max Length Tokens       |                  4096                  |
|        Max New Tokens        |                  2048                  |
|          Chunk Size          |                  256                   |
|        Chunk Overlap         |                   20                   |
|     Number of Documents      |                   39                   |
+------------------------------+----------------------------------------+

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/vipul-maheshwari/vipul-maheshwari.github.io/blob/main/images/make_your_application_with_rag/cat2.png?raw=true&quot; alt=&quot;cat2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Have fun experimenting with various data sources! You can try changing the website addresses, adding new PDF files or maybe change the template a bit. LLMs are fun, you never know what you get!&lt;/p&gt;

&lt;h3 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h3&gt;
&lt;p&gt;There are plenty of things we can adjust here. We could switch to a more effective embedding model for better indexing, try different searching techniques for the retriever, add a reranker to improve the ranking of documents, or use a more advanced LLM with a larger context window and faster response times. Essentially, every RAG application is just an enhanced version based on these factors. However, the fundamental concept of how a RAG application works always remains the same.&lt;/p&gt;

&lt;p&gt;Here is the &lt;a href=&quot;https://colab.research.google.com/drive/1YsOfovVdNPBwCDMWHvLfOaNtqXn4qXTs?usp=sharing&quot;&gt;collab&lt;/a&gt; link for the reference..&lt;/p&gt;
</content>
 </entry>
 

</feed>
