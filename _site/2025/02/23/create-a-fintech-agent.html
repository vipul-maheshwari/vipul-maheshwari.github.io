<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="Creating a Fintech AI agent without any framework" /><meta property="og:locale" content="en_US" /><meta name="description" content="This post gives a detailed introduction on how agents work and how we can create one using the simple Python" /><meta property="og:description" content="This post gives a detailed introduction on how agents work and how we can create one using the simple Python" /><link rel="canonical" href="http://localhost:4000/2025/02/23/create-a-fintech-agent" /><meta property="og:url" content="http://localhost:4000/2025/02/23/create-a-fintech-agent" /><meta property="og:site_name" content="Deox Labs" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-02-23T00:00:00+05:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Creating a Fintech AI agent without any framework" /><meta name="twitter:site" content="@fuxssss" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-23T00:00:00+05:30","datePublished":"2025-02-23T00:00:00+05:30","description":"This post gives a detailed introduction on how agents work and how we can create one using the simple Python","headline":"Creating a Fintech AI agent without any framework","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2025/02/23/create-a-fintech-agent"},"url":"http://localhost:4000/2025/02/23/create-a-fintech-agent"}</script><title> Creating a Fintech AI agent without any framework - Deox Labs</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Deox Labs" href="/atom.xml"><link rel="alternate" type="application/json" title="Deox Labs" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#f5f5f5;max-width:100%;overflow-x:auto}code{padding:.1rem;font-size:.85rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%;background:none;display:block;margin:auto}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.post ol,.project ul,.post ol,.post ul{padding-left:1rem}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}@media print{.no-print,.no-print *{display:none !important}}.back-to-top{position:fixed;bottom:20px;right:20px;background-color:#fff;color:#000;padding:10px;text-decoration:none;border-radius:5px;display:block;margin-right:20%}</style></head><body><main><header aria-hidden="true" class="no-print"> <!--<h1 class="logo">Deox Labs</h1>--><nav role="navigation" aria-hidden="true"><ul><li><a href="/" >Home</a></li><li><a href="/about" >About</a></li><li><a href="/contact" >Contact</a></li><li><a href="/projects" >Projects</a></li></ul></nav></header><section class="post"><h1>Creating a Fintech AI agent without any framework</h1><p>AI agents are everywhere, and they’re only going to get more common in the next few years. To put it simply, imagine a bunch of small digital assistants—agents—that analyze what’s going on, make decisions, and get things done. This makes me wonder: how are we going to handle all these agents in the future? How do we trust them to make decisions for us and let them operate on their own?</p><p>Right now, there are tons of frameworks that let you quickly build AI agents. Honestly, it feels like every other day a new “low-code” tool pops up, claiming to make building agents super easy. These tools are everywhere—simple drag-and-drop boards or text boxes where you just connect a few prompts and data, and boom, you have your agent.</p><p>At the heart of every AI agent, there are three key parts: the Model, the Tools, and the Reasoning Loop.</p><ol><li><p>The Model: This is the Large Language Model (LLM) that powers the agent. It’s the core of the agent’s intelligence, trained on tons of text data to understand language and follow complex instructions. This model gives the agent its ability to think and respond like a human.</p></li><li><p>The Tools: These are the specific functions that the AI agent uses to interact with its environment and carry out tasks. Whether it’s fetching data, calling APIs, or interacting with other software, tools are what make the agent capable of performing its job.</p></li><li><p>The Reasoning Loop: This is how the agent makes decisions. It’s a process that allows the agent to solve problems, figure out the best course of action, and get things done.</p></li></ol><p>In this post, I’m going to show you something a bit different. Instead of using a framework, I’ll walk you through building a fintech agent with Python. This agent will help with decision-making when it comes to loans and insurance.</p><h3 id="whats-the-deal">What’s the deal?</h3><p>So how this fintech agent works, Well, imagine you’re a FinTech company, now customers hit you up with questions like, “Can I borrow $10K for a new kitchen? I am 26 years old” or “I crashed my car—will you cover it?” Lol, I would literally close that insurance claim for sure.</p><p>Ok the point is What we need is a system that’s fast, smart, and trustworthy in making the decisions on the loan queries as well the insurance claims. Now what I did is, instead of a single alone Agent with all the tools, we will have three agents, loan, insurance and the kernel ones.</p><ol><li>Loan Agent: Takes a query, figures out intent (e.g., “home improvement”), and predicts if they’re loan-worthy based on age, income, and amount with the help of a ML model.</li><li>Insurance Side: Reads a claim, compares it to past ones, and decides if it’s payable—think semantic search over a claims database.</li><li>Kernel: The brains tying it together, routing queries to the right agent.</li></ol><p>Why raw Python? It’s flexible; I mean I am just presenting a POC and the companies can literally customize it to their data and needs, no black-box framework nonsense. The <a href="https://www.kaggle.com/datasets/laotse/credit-risk-dataset">Credit Risk Dataset</a> and synthetic claims are just stand-ins; real firms would use their own loan histories and claim records.</p><p>Here’s the big picture: we’ve got a Kernel Agent directing traffic, a Loan Agent predicting eligibility with ML, and an Insurance Agent checking claims against a vector database.</p><p>I am using the Credit Risk Dataset as a demo for loans, in real;companies can use the CIBIL score like metric to check if the given person is eligible for the loans or not. But for the sake of this POC, I have utilized the dataset, trained a random forest and use it for the predictive analysis.</p><p>For the insurance-agent, I have used a synthetic pipeline to generate a dataset which consists of the fake insurance queries, and the target is based on that conversation, if the insurance claim is done, the target is one, insurance—placeholders to show the ropes. Companies can plug in their own data instead.</p><p>Well I would say you can tune the dataset you want as you require the data. Let’s break it down step by step, with code and the why behind it all.</p><h3 id="setting-the-stage-libraries-and-setup">Setting the Stage: Libraries and Setup</h3><p>We start by grabbing our tools—libraries that handle data, models, and vectors:</p><pre><code class="language-python">import pandas as pd
import joblib
import pyarrow as pa
from sentence_transformers import SentenceTransformer
import lancedb
from mistralai import Mistral
import os
from abc import ABC, abstractmethod
from typing import Any

# Abstract Tool Class
class Tool(ABC):
    @abstractmethod
    def name(self) -&gt; str:
        pass

    @abstractmethod
    def description(self) -&gt; str:
        pass

    @abstractmethod
    def use(self, *args, **kwargs) -&gt; Any:
        pass

# Initialize Mistral and Embedder
api_key = os.environ.get("MISTRAL_API_KEY", "xxxxxxxxxxxxx")  
if not api_key:
    raise ValueError("Please set the MISTRAL_API_KEY environment variable.")

model = "mistral-large-latest"
client = Mistral(api_key=api_key)
embedder = SentenceTransformer('all-MiniLM-L6-v2')

# Connect to LanceDB
db = lancedb.connect('./lancedb_data')
</code></pre><p>For the quick demonstration, I am going to use <code>mistral-large-latest</code> model from the Mistral for LLM tasks and the intent classification in the Loan queries. The <code>Tool</code> class is our way to keep the agents modular - every tool gets a clear job.</p><h2 id="loan-agent-predicting-with-ml">Loan Agent: Predicting with ML</h2><p>The Loan Agent decides who gets a loan. We’re using the Credit Risk Dataset as a demo—it’s got age, income, loan amounts, and intents, perfect for a proof-of-concept.</p><p>#</p><span class="meta"><time datetime="2025-02-23T00:00:00+05:30">February 23, 2025</time></span></section><!-- --- layout: default ---<section class="post"><h2>Creating a Fintech AI agent without any framework</h2><p>AI agents are everywhere, and they’re only going to get more common in the next few years. To put it simply, imagine a bunch of small digital assistants—agents—that analyze what’s going on, make decisions, and get things done. This makes me wonder: how are we going to handle all these agents in the future? How do we trust them to make decisions for us and let them operate on their own?</p><p>Right now, there are tons of frameworks that let you quickly build AI agents. Honestly, it feels like every other day a new “low-code” tool pops up, claiming to make building agents super easy. These tools are everywhere—simple drag-and-drop boards or text boxes where you just connect a few prompts and data, and boom, you have your agent.</p><p>At the heart of every AI agent, there are three key parts: the Model, the Tools, and the Reasoning Loop.</p><ol><li><p>The Model: This is the Large Language Model (LLM) that powers the agent. It’s the core of the agent’s intelligence, trained on tons of text data to understand language and follow complex instructions. This model gives the agent its ability to think and respond like a human.</p></li><li><p>The Tools: These are the specific functions that the AI agent uses to interact with its environment and carry out tasks. Whether it’s fetching data, calling APIs, or interacting with other software, tools are what make the agent capable of performing its job.</p></li><li><p>The Reasoning Loop: This is how the agent makes decisions. It’s a process that allows the agent to solve problems, figure out the best course of action, and get things done.</p></li></ol><p>In this post, I’m going to show you something a bit different. Instead of using a framework, I’ll walk you through building a fintech agent with Python. This agent will help with decision-making when it comes to loans and insurance.</p><h3 id="whats-the-deal">What’s the deal?</h3><p>So how this fintech agent works, Well, imagine you’re a FinTech company, now customers hit you up with questions like, “Can I borrow $10K for a new kitchen? I am 26 years old” or “I crashed my car—will you cover it?” Lol, I would literally close that insurance claim for sure.</p><p>Ok the point is What we need is a system that’s fast, smart, and trustworthy in making the decisions on the loan queries as well the insurance claims. Now what I did is, instead of a single alone Agent with all the tools, we will have three agents, loan, insurance and the kernel ones.</p><ol><li>Loan Agent: Takes a query, figures out intent (e.g., “home improvement”), and predicts if they’re loan-worthy based on age, income, and amount with the help of a ML model.</li><li>Insurance Side: Reads a claim, compares it to past ones, and decides if it’s payable—think semantic search over a claims database.</li><li>Kernel: The brains tying it together, routing queries to the right agent.</li></ol><p>Why raw Python? It’s flexible; I mean I am just presenting a POC and the companies can literally customize it to their data and needs, no black-box framework nonsense. The <a href="https://www.kaggle.com/datasets/laotse/credit-risk-dataset">Credit Risk Dataset</a> and synthetic claims are just stand-ins; real firms would use their own loan histories and claim records.</p><p>Here’s the big picture: we’ve got a Kernel Agent directing traffic, a Loan Agent predicting eligibility with ML, and an Insurance Agent checking claims against a vector database.</p><p>I am using the Credit Risk Dataset as a demo for loans, in real;companies can use the CIBIL score like metric to check if the given person is eligible for the loans or not. But for the sake of this POC, I have utilized the dataset, trained a random forest and use it for the predictive analysis.</p><p>For the insurance-agent, I have used a synthetic pipeline to generate a dataset which consists of the fake insurance queries, and the target is based on that conversation, if the insurance claim is done, the target is one, insurance—placeholders to show the ropes. Companies can plug in their own data instead.</p><p>Well I would say you can tune the dataset you want as you require the data. Let’s break it down step by step, with code and the why behind it all.</p><h3 id="setting-the-stage-libraries-and-setup">Setting the Stage: Libraries and Setup</h3><p>We start by grabbing our tools—libraries that handle data, models, and vectors:</p><pre><code class="language-python">import pandas as pd
import joblib
import pyarrow as pa
from sentence_transformers import SentenceTransformer
import lancedb
from mistralai import Mistral
import os
from abc import ABC, abstractmethod
from typing import Any

# Abstract Tool Class
class Tool(ABC):
    @abstractmethod
    def name(self) -&gt; str:
        pass

    @abstractmethod
    def description(self) -&gt; str:
        pass

    @abstractmethod
    def use(self, *args, **kwargs) -&gt; Any:
        pass

# Initialize Mistral and Embedder
api_key = os.environ.get("MISTRAL_API_KEY", "xxxxxxxxxxxxx")  
if not api_key:
    raise ValueError("Please set the MISTRAL_API_KEY environment variable.")

model = "mistral-large-latest"
client = Mistral(api_key=api_key)
embedder = SentenceTransformer('all-MiniLM-L6-v2')

# Connect to LanceDB
db = lancedb.connect('./lancedb_data')
</code></pre><p>For the quick demonstration, I am going to use <code>mistral-large-latest</code> model from the Mistral for LLM tasks and the intent classification in the Loan queries. The <code>Tool</code> class is our way to keep the agents modular - every tool gets a clear job.</p><h2 id="loan-agent-predicting-with-ml">Loan Agent: Predicting with ML</h2><p>The Loan Agent decides who gets a loan. We’re using the Credit Risk Dataset as a demo—it’s got age, income, loan amounts, and intents, perfect for a proof-of-concept.</p><p>#</p><span class="meta"><time datetime="2025-02-23T00:00:00+05:30">February 23, 2025</time> &middot; <a href="/tag/AI Agents">AI Agents</a>, <a href="/tag/Python Agent from Scratch">Python Agent from Scratch</a></span>--> <!--</section>--></main><script async src="https://www.googletagmanager.com/gtag/js?id=G-JBZRCCYMBP"></script> <script> window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag('js', new Date()); gtag('config', 'G-JBZRCCYMBP'); </script></body></html>
